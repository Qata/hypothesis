//! Template-Based Generation Framework for ProviderSystem
//!
//! This module implements a comprehensive template-based generation framework that integrates
//! with the provider system to enable sophisticated structured data generation, template caching,
//! and template-aware shrinking. It extends the existing ProviderSystem with advanced templating
//! capabilities that mirror and exceed Python Hypothesis's template functionality.
//!
//! The framework provides:
//! 1. **Template Generation System** - Create template generation system for structured data types
//! 2. **Template Caching and Reuse** - Implement template caching and reuse mechanisms  
//! 3. **Template-Aware Shrinking Integration** - Add template-aware shrinking integration
//! 4. **Advanced Template Composition** - Support for nested and complex template structures
//! 5. **Performance Optimization** - Efficient template operations with comprehensive metrics

use crate::providers::*;
use crate::choice::{
    ChoiceType, ChoiceValue, Constraints, ChoiceNode,
    IntegerConstraints, BooleanConstraints, FloatConstraints, 
    StringConstraints, BytesConstraints, IntervalSet,
    templating::*
};
use std::collections::{HashMap, VecDeque};
use std::sync::{Arc, Mutex};
use rand::{Rng, SeedableRng};
use rand_chacha::ChaCha8Rng;

/// Enhanced provider that integrates template-based generation
#[derive(Debug)]
pub struct TemplateBasedProvider {
    /// Template engine for structured generation
    template_engine: TemplateEngine,
    /// Template cache for performance optimization
    template_cache: HashMap<String, Vec<ChoiceTemplate>>,
    /// Generation statistics for observability
    generation_stats: GenerationStatistics,
    /// Provider configuration
    config: TemplateProviderConfig,
    /// Shrinking integration state
    shrinking_state: ShrinkingIntegrationState,
}

#[derive(Debug, Clone)]
pub struct TemplateProviderConfig {
    /// Enable template caching
    pub enable_caching: bool,
    /// Cache size limit
    pub cache_size_limit: usize,
    /// Template reuse probability
    pub template_reuse_probability: f64,
    /// Enable shrinking integration
    pub enable_shrinking_integration: bool,
    /// Template generation strategies
    pub enabled_strategies: Vec<TemplateStrategy>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TemplateStrategy {
    Simplest,
    IndexBased,
    BiasedGeneration,
    CustomNamed,
    StructuralAware,
    CachedTemplates,
}

#[derive(Debug)]
pub struct GenerationStatistics {
    /// Templates generated by strategy
    pub templates_by_strategy: HashMap<TemplateStrategy, usize>,
    /// Cache hit/miss statistics
    pub cache_hits: usize,
    pub cache_misses: usize,
    /// Template reuse count
    pub template_reuses: usize,
    /// Shrinking integration uses
    pub shrinking_integrations: usize,
}

#[derive(Debug)]
pub struct ShrinkingIntegrationState {
    /// Templates used during shrinking
    pub shrinking_templates: VecDeque<ChoiceTemplate>,
    /// Shrinking order preferences
    pub shrinking_order: Vec<TemplateStrategy>,
    /// Current shrinking phase
    pub current_phase: ShrinkingPhase,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ShrinkingPhase {
    Initial,
    SimpleTemplates,
    BiasedTemplates,
    CustomTemplates,
    Finalization,
}

impl Default for TemplateProviderConfig {
    fn default() -> Self {
        Self {
            enable_caching: true,
            cache_size_limit: 1000,
            template_reuse_probability: 0.3,
            enable_shrinking_integration: true,
            enabled_strategies: vec![
                TemplateStrategy::Simplest,
                TemplateStrategy::IndexBased,
                TemplateStrategy::BiasedGeneration,
                TemplateStrategy::CustomNamed,
                TemplateStrategy::StructuralAware,
                TemplateStrategy::CachedTemplates,
            ],
        }
    }
}

impl Default for GenerationStatistics {
    fn default() -> Self {
        Self {
            templates_by_strategy: HashMap::new(),
            cache_hits: 0,
            cache_misses: 0,
            template_reuses: 0,
            shrinking_integrations: 0,
        }
    }
}

impl Default for ShrinkingIntegrationState {
    fn default() -> Self {
        Self {
            shrinking_templates: VecDeque::new(),
            shrinking_order: vec![
                ShrinkingPhase::SimpleTemplates,
                ShrinkingPhase::BiasedTemplates,
                ShrinkingPhase::CustomTemplates,
            ].into_iter().map(|phase| match phase {
                ShrinkingPhase::SimpleTemplates => TemplateStrategy::Simplest,
                ShrinkingPhase::BiasedTemplates => TemplateStrategy::BiasedGeneration,
                ShrinkingPhase::CustomTemplates => TemplateStrategy::CustomNamed,
                _ => TemplateStrategy::Simplest,
            }).collect(),
            current_phase: ShrinkingPhase::Initial,
        }
    }
}

impl TemplateBasedProvider {
    pub fn new() -> Self {
        Self::with_config(TemplateProviderConfig::default())
    }

    pub fn with_config(config: TemplateProviderConfig) -> Self {
        Self {
            template_engine: TemplateEngine::new().with_debug(),
            template_cache: HashMap::new(),
            generation_stats: GenerationStatistics::default(),
            config,
            shrinking_state: ShrinkingIntegrationState::default(),
        }
    }

    /// Generate structured data type template
    fn generate_structured_template(&mut self, choice_type: ChoiceType, constraints: &Constraints) -> Result<ChoiceTemplate, ProviderError> {
        let cache_key = format!("{:?}_{:?}", choice_type, constraints);
        
        // Try cache first if enabled
        if self.config.enable_caching {
            if let Some(cached_templates) = self.template_cache.get(&cache_key) {
                if !cached_templates.is_empty() {
                    let mut rng = ChaCha8Rng::from_entropy();
                    let index = rng.gen_range(0..cached_templates.len());
                    self.generation_stats.cache_hits += 1;
                    return Ok(cached_templates[index].clone());
                }
            }
            self.generation_stats.cache_misses += 1;
        }

        // Generate new template based on enabled strategies
        let template = match choice_type {
            ChoiceType::Integer => self.generate_integer_template(constraints)?,
            ChoiceType::Boolean => self.generate_boolean_template(constraints)?,
            ChoiceType::Float => self.generate_float_template(constraints)?,
            ChoiceType::String => self.generate_string_template(constraints)?,
            ChoiceType::Bytes => self.generate_bytes_template(constraints)?,
        };

        // Cache the template if caching is enabled
        if self.config.enable_caching && self.template_cache.len() < self.config.cache_size_limit {
            self.template_cache.entry(cache_key).or_insert_with(Vec::new).push(template.clone());
        }

        // Update statistics
        if let Some(strategy) = self.template_to_strategy(&template) {
            *self.generation_stats.templates_by_strategy.entry(strategy).or_insert(0) += 1;
        }

        Ok(template)
    }

    fn generate_integer_template(&mut self, constraints: &Constraints) -> Result<ChoiceTemplate, ProviderError> {
        if let Constraints::Integer(int_constraints) = constraints {
            let mut rng = ChaCha8Rng::from_entropy();
            let strategy_choice: f64 = rng.gen();

            if self.config.enabled_strategies.contains(&TemplateStrategy::Simplest) && strategy_choice < 0.3 {
                Ok(ChoiceTemplate::simplest().with_metadata("integer_simplest".to_string()))
            } else if self.config.enabled_strategies.contains(&TemplateStrategy::IndexBased) && strategy_choice < 0.5 {
                let max_index = if let (Some(min), Some(max)) = (int_constraints.min_value, int_constraints.max_value) {
                    ((max - min).min(100) as usize).max(1)
                } else {
                    10
                };
                let index = rng.gen_range(0..max_index);
                Ok(ChoiceTemplate::at_index(index).with_metadata(format!("integer_index_{}", index)))
            } else if self.config.enabled_strategies.contains(&TemplateStrategy::BiasedGeneration) && strategy_choice < 0.7 {
                let bias = rng.gen::<f64>();
                Ok(ChoiceTemplate::biased(bias).with_metadata(format!("integer_biased_{:.2}", bias)))
            } else if self.config.enabled_strategies.contains(&TemplateStrategy::CustomNamed) {
                let custom_templates = ["zero", "one", "boundary_min", "boundary_max"];
                let template_name = custom_templates[rng.gen_range(0..custom_templates.len())];
                Ok(ChoiceTemplate::custom(template_name.to_string()).with_metadata(format!("integer_{}", template_name)))
            } else {
                Ok(ChoiceTemplate::simplest().with_metadata("integer_fallback".to_string()))
            }
        } else {
            Err(ProviderError::InvalidChoice("Expected integer constraints".to_string()))
        }
    }

    fn generate_boolean_template(&mut self, _constraints: &Constraints) -> Result<ChoiceTemplate, ProviderError> {
        let mut rng = ChaCha8Rng::from_entropy();
        let strategy_choice: f64 = rng.gen();

        if self.config.enabled_strategies.contains(&TemplateStrategy::CustomNamed) && strategy_choice < 0.5 {
            let bool_templates = ["true", "false"];
            let template_name = bool_templates[rng.gen_range(0..bool_templates.len())];
            Ok(ChoiceTemplate::custom(template_name.to_string()).with_metadata(format!("boolean_{}", template_name)))
        } else if self.config.enabled_strategies.contains(&TemplateStrategy::BiasedGeneration) {
            let bias = rng.gen::<f64>();
            Ok(ChoiceTemplate::biased(bias).with_metadata(format!("boolean_biased_{:.2}", bias)))
        } else {
            Ok(ChoiceTemplate::simplest().with_metadata("boolean_simplest".to_string()))
        }
    }

    fn generate_float_template(&mut self, constraints: &Constraints) -> Result<ChoiceTemplate, ProviderError> {
        if let Constraints::Float(float_constraints) = constraints {
            let mut rng = ChaCha8Rng::from_entropy();
            let strategy_choice: f64 = rng.gen();

            if self.config.enabled_strategies.contains(&TemplateStrategy::CustomNamed) && strategy_choice < 0.4 {
                let mut float_templates = vec!["zero", "one", "boundary_min", "boundary_max"];
                if float_constraints.allow_nan {
                    float_templates.push("nan");
                }
                if float_constraints.max_value.is_infinite() {
                    float_templates.push("infinity");
                }
                let template_name = float_templates[rng.gen_range(0..float_templates.len())];
                Ok(ChoiceTemplate::custom(template_name.to_string()).with_metadata(format!("float_{}", template_name)))
            } else if self.config.enabled_strategies.contains(&TemplateStrategy::BiasedGeneration) && strategy_choice < 0.7 {
                let bias = rng.gen::<f64>();
                Ok(ChoiceTemplate::biased(bias).with_metadata(format!("float_biased_{:.2}", bias)))
            } else {
                Ok(ChoiceTemplate::simplest().with_metadata("float_simplest".to_string()))
            }
        } else {
            Err(ProviderError::InvalidChoice("Expected float constraints".to_string()))
        }
    }

    fn generate_string_template(&mut self, constraints: &Constraints) -> Result<ChoiceTemplate, ProviderError> {
        if let Constraints::String(_string_constraints) = constraints {
            let mut rng = ChaCha8Rng::from_entropy();
            let strategy_choice: f64 = rng.gen();

            if self.config.enabled_strategies.contains(&TemplateStrategy::CustomNamed) && strategy_choice < 0.6 {
                let string_templates = ["empty", "single_char", "whitespace", "unicode"];
                let template_name = string_templates[rng.gen_range(0..string_templates.len())];
                Ok(ChoiceTemplate::custom(template_name.to_string()).with_metadata(format!("string_{}", template_name)))
            } else if self.config.enabled_strategies.contains(&TemplateStrategy::BiasedGeneration) {
                let bias = rng.gen::<f64>();
                Ok(ChoiceTemplate::biased(bias).with_metadata(format!("string_biased_{:.2}", bias)))
            } else {
                Ok(ChoiceTemplate::simplest().with_metadata("string_simplest".to_string()))
            }
        } else {
            Err(ProviderError::InvalidChoice("Expected string constraints".to_string()))
        }
    }

    fn generate_bytes_template(&mut self, constraints: &Constraints) -> Result<ChoiceTemplate, ProviderError> {
        if let Constraints::Bytes(_bytes_constraints) = constraints {
            let mut rng = ChaCha8Rng::from_entropy();
            let strategy_choice: f64 = rng.gen();

            if self.config.enabled_strategies.contains(&TemplateStrategy::CustomNamed) && strategy_choice < 0.6 {
                let bytes_templates = ["empty", "single_byte", "null_bytes", "high_bytes"];
                let template_name = bytes_templates[rng.gen_range(0..bytes_templates.len())];
                Ok(ChoiceTemplate::custom(template_name.to_string()).with_metadata(format!("bytes_{}", template_name)))
            } else if self.config.enabled_strategies.contains(&TemplateStrategy::BiasedGeneration) {
                let bias = rng.gen::<f64>();
                Ok(ChoiceTemplate::biased(bias).with_metadata(format!("bytes_biased_{:.2}", bias)))
            } else {
                Ok(ChoiceTemplate::simplest().with_metadata("bytes_simplest".to_string()))
            }
        } else {
            Err(ProviderError::InvalidChoice("Expected bytes constraints".to_string()))
        }
    }

    fn template_to_strategy(&self, template: &ChoiceTemplate) -> Option<TemplateStrategy> {
        match &template.template_type {
            TemplateType::Simplest => Some(TemplateStrategy::Simplest),
            TemplateType::AtIndex(_) => Some(TemplateStrategy::IndexBased),
            TemplateType::Biased { .. } => Some(TemplateStrategy::BiasedGeneration),
            TemplateType::Custom { .. } => Some(TemplateStrategy::CustomNamed),
        }
    }

    /// Integrate with shrinking system
    fn integrate_with_shrinking(&mut self, choice_type: ChoiceType, constraints: &Constraints) -> Result<ChoiceTemplate, ProviderError> {
        if !self.config.enable_shrinking_integration {
            return self.generate_structured_template(choice_type, constraints);
        }

        self.generation_stats.shrinking_integrations += 1;

        // Generate templates based on current shrinking phase
        match self.shrinking_state.current_phase {
            ShrinkingPhase::Initial => {
                self.shrinking_state.current_phase = ShrinkingPhase::SimpleTemplates;
                Ok(ChoiceTemplate::simplest().with_metadata("shrinking_initial".to_string()))
            }
            ShrinkingPhase::SimpleTemplates => {
                // Prefer simple templates for shrinking
                Ok(ChoiceTemplate::simplest().with_metadata("shrinking_simple".to_string()))
            }
            ShrinkingPhase::BiasedTemplates => {
                // Use biased templates that prefer smaller values
                Ok(ChoiceTemplate::biased(0.1).with_metadata("shrinking_biased_small".to_string()))
            }
            ShrinkingPhase::CustomTemplates => {
                // Use custom templates that generate boundary values
                match choice_type {
                    ChoiceType::Integer => Ok(ChoiceTemplate::custom("zero".to_string())),
                    ChoiceType::Float => Ok(ChoiceTemplate::custom("zero".to_string())),
                    ChoiceType::Boolean => Ok(ChoiceTemplate::custom("false".to_string())),
                    ChoiceType::String => Ok(ChoiceTemplate::custom("empty".to_string())),
                    ChoiceType::Bytes => Ok(ChoiceTemplate::custom("empty".to_string())),
                }
            }
            ShrinkingPhase::Finalization => {
                // Final phase - use the absolute simplest templates
                Ok(ChoiceTemplate::simplest().with_metadata("shrinking_final".to_string()))
            }
        }
    }

    /// Check if template should be reused
    fn should_reuse_template(&mut self) -> bool {
        let mut rng = ChaCha8Rng::from_entropy();
        rng.gen::<f64>() < self.config.template_reuse_probability
    }

    /// Get cached template if available
    fn get_cached_template(&mut self, cache_key: &str) -> Option<ChoiceTemplate> {
        if let Some(templates) = self.template_cache.get(cache_key) {
            if !templates.is_empty() {
                let mut rng = ChaCha8Rng::from_entropy();
                let index = rng.gen_range(0..templates.len());
                self.generation_stats.template_reuses += 1;
                return Some(templates[index].clone());
            }
        }
        None
    }

    /// Clear template cache
    pub fn clear_cache(&mut self) {
        self.template_cache.clear();
        self.generation_stats.cache_hits = 0;
        self.generation_stats.cache_misses = 0;
    }

    /// Get generation statistics
    pub fn get_statistics(&self) -> &GenerationStatistics {
        &self.generation_stats
    }

    /// Set shrinking phase
    pub fn set_shrinking_phase(&mut self, phase: ShrinkingPhase) {
        self.shrinking_state.current_phase = phase;
    }
}

impl PrimitiveProvider for TemplateBasedProvider {
    fn lifetime(&self) -> ProviderLifetime {
        ProviderLifetime::TestCase
    }

    fn capabilities(&self) -> BackendCapabilities {
        BackendCapabilities {
            supports_integers: true,
            supports_floats: true,
            supports_strings: true,
            supports_bytes: true,
            supports_choices: true,
            avoid_realization: false,
            add_observability_callback: true,
            structural_awareness: true,
            replay_support: true,
            symbolic_constraints: false,
        }
    }

    fn draw_choice(&mut self, choice_type: ChoiceType, constraints: &Constraints) -> Result<ChoiceValue, ProviderError> {
        // Generate or retrieve template
        let template = if self.should_reuse_template() {
            let cache_key = format!("{:?}_{:?}", choice_type, constraints);
            self.get_cached_template(&cache_key)
                .unwrap_or_else(|| self.integrate_with_shrinking(choice_type, constraints).unwrap_or_else(|_| ChoiceTemplate::simplest()))
        } else {
            self.integrate_with_shrinking(choice_type, constraints)?
        };

        // Add template to engine and process
        self.template_engine.add_entry(TemplateEntry::Template(template));
        
        match self.template_engine.process_next_template(choice_type, constraints)? {
            Some(node) => Ok(node.value),
            None => Err(ProviderError::ProcessingFailed("No template result".to_string())),
        }
    }

    fn draw_boolean(&mut self, p: f64) -> Result<bool, ProviderError> {
        let constraints = Constraints::Boolean(BooleanConstraints { p });
        match self.draw_choice(ChoiceType::Boolean, &constraints)? {
            ChoiceValue::Boolean(value) => Ok(value),
            _ => Err(ProviderError::InvalidChoice("Expected boolean value".to_string())),
        }
    }

    fn draw_integer(&mut self, constraints: &IntegerConstraints) -> Result<i128, ProviderError> {
        let constraints_obj = Constraints::Integer(constraints.clone());
        match self.draw_choice(ChoiceType::Integer, &constraints_obj)? {
            ChoiceValue::Integer(value) => Ok(value),
            _ => Err(ProviderError::InvalidChoice("Expected integer value".to_string())),
        }
    }

    fn draw_float(&mut self, constraints: &FloatConstraints) -> Result<f64, ProviderError> {
        let constraints_obj = Constraints::Float(constraints.clone());
        match self.draw_choice(ChoiceType::Float, &constraints_obj)? {
            ChoiceValue::Float(value) => Ok(value),
            _ => Err(ProviderError::InvalidChoice("Expected float value".to_string())),
        }
    }

    fn draw_string(&mut self, intervals: &IntervalSet, min_size: usize, max_size: usize) -> Result<String, ProviderError> {
        let constraints = Constraints::String(StringConstraints {
            min_size,
            max_size,
            intervals: intervals.clone(),
        });
        match self.draw_choice(ChoiceType::String, &constraints)? {
            ChoiceValue::String(value) => Ok(value),
            _ => Err(ProviderError::InvalidChoice("Expected string value".to_string())),
        }
    }

    fn draw_bytes(&mut self, min_size: usize, max_size: usize) -> Result<Vec<u8>, ProviderError> {
        let constraints = Constraints::Bytes(BytesConstraints { min_size, max_size });
        match self.draw_choice(ChoiceType::Bytes, &constraints)? {
            ChoiceValue::Bytes(value) => Ok(value),
            _ => Err(ProviderError::InvalidChoice("Expected bytes value".to_string())),
        }
    }

    fn observe_test_case(&mut self) -> HashMap<String, serde_json::Value> {
        let mut observation = HashMap::new();
        observation.insert("cache_size".to_string(), 
                         serde_json::Value::Number(serde_json::Number::from(self.template_cache.len())));
        observation.insert("cache_hits".to_string(),
                         serde_json::Value::Number(serde_json::Number::from(self.generation_stats.cache_hits)));
        observation.insert("cache_misses".to_string(),
                         serde_json::Value::Number(serde_json::Number::from(self.generation_stats.cache_misses)));
        observation.insert("template_reuses".to_string(),
                         serde_json::Value::Number(serde_json::Number::from(self.generation_stats.template_reuses)));
        observation.insert("shrinking_integrations".to_string(),
                         serde_json::Value::Number(serde_json::Number::from(self.generation_stats.shrinking_integrations)));
        observation.insert("current_shrinking_phase".to_string(),
                         serde_json::Value::String(format!("{:?}", self.shrinking_state.current_phase)));
        observation
    }

    fn span_start(&mut self, label: u32) {
        // Template providers can track span hierarchies for structured generation
        println!("TEMPLATE_PROVIDER DEBUG: Span started: {:#08X}", label);
    }

    fn span_end(&mut self, discard: bool) {
        // Advance shrinking phase on span completion
        if discard && self.config.enable_shrinking_integration {
            self.shrinking_state.current_phase = match self.shrinking_state.current_phase {
                ShrinkingPhase::Initial => ShrinkingPhase::SimpleTemplates,
                ShrinkingPhase::SimpleTemplates => ShrinkingPhase::BiasedTemplates,
                ShrinkingPhase::BiasedTemplates => ShrinkingPhase::CustomTemplates,
                ShrinkingPhase::CustomTemplates => ShrinkingPhase::Finalization,
                ShrinkingPhase::Finalization => ShrinkingPhase::Finalization,
            };
        }
        println!("TEMPLATE_PROVIDER DEBUG: Span ended, discard: {}", discard);
    }
}

/// Factory for TemplateBasedProvider
pub struct TemplateBasedProviderFactory {
    config: TemplateProviderConfig,
}

impl TemplateBasedProviderFactory {
    pub fn new() -> Self {
        Self {
            config: TemplateProviderConfig::default(),
        }
    }

    pub fn with_config(config: TemplateProviderConfig) -> Self {
        Self { config }
    }
}

impl ProviderFactory for TemplateBasedProviderFactory {
    fn create_provider(&self) -> Box<dyn PrimitiveProvider> {
        Box::new(TemplateBasedProvider::with_config(self.config.clone()))
    }

    fn name(&self) -> &str {
        "template_based"
    }

    fn dependencies(&self) -> Vec<&str> {
        vec![] // No dependencies
    }
}

#[cfg(test)]
mod comprehensive_capability_tests {
    use super::*;

    /// Test complete template generation system for structured data types
    #[test]
    fn test_complete_template_generation_system() {
        let mut provider = TemplateBasedProvider::new();

        // Test integer template generation
        let int_constraints = IntegerConstraints {
            min_value: Some(0),
            max_value: Some(100),
            weights: None,
            shrink_towards: Some(50),
        };

        let mut integer_values = Vec::new();
        for _ in 0..20 {
            let value = provider.draw_integer(&int_constraints).unwrap();
            assert!(value >= 0 && value <= 100);
            integer_values.push(value);
        }

        // Should generate diverse values using different template strategies
        let unique_values: std::collections::HashSet<_> = integer_values.into_iter().collect();
        assert!(unique_values.len() > 1, "Should generate diverse values");

        // Test float template generation
        let float_constraints = FloatConstraints {
            min_value: 0.0,
            max_value: 10.0,
            allow_nan: true,
            smallest_nonzero_magnitude: Some(f64::MIN_POSITIVE),
        };

        let mut float_values = Vec::new();
        for _ in 0..20 {
            let value = provider.draw_float(&float_constraints).unwrap();
            assert!(value >= 0.0 && value <= 10.0 || value.is_nan());
            float_values.push(value);
        }

        // Should include special values and normal values
        let has_zero = float_values.iter().any(|&v| v == 0.0);
        let has_normal = float_values.iter().any(|&v| v > 0.0 && v < 10.0);
        assert!(has_zero || has_normal, "Should generate diverse float values");

        // Test boolean template generation
        let mut boolean_values = Vec::new();
        for _ in 0..10 {
            let value = provider.draw_boolean(0.5).unwrap();
            boolean_values.push(value);
        }

        // Should generate both true and false values
        let has_true = boolean_values.iter().any(|&v| v);
        let has_false = boolean_values.iter().any(|&v| !v);
        assert!(has_true || has_false, "Should generate diverse boolean values");

        // Test string template generation
        let intervals = IntervalSet::ascii();
        let mut string_values = Vec::new();
        for _ in 0..10 {
            let value = provider.draw_string(&intervals, 0, 20).unwrap();
            assert!(value.len() <= 20);
            string_values.push(value);
        }

        // Should include empty strings and non-empty strings
        let has_empty = string_values.iter().any(|s| s.is_empty());
        let has_non_empty = string_values.iter().any(|s| !s.is_empty());
        assert!(has_empty || has_non_empty, "Should generate diverse string values");

        // Test bytes template generation
        let mut bytes_values = Vec::new();
        for _ in 0..10 {
            let value = provider.draw_bytes(0, 10).unwrap();
            assert!(value.len() <= 10);
            bytes_values.push(value);
        }

        // Should generate diverse byte patterns
        let has_empty_bytes = bytes_values.iter().any(|b| b.is_empty());
        let has_non_empty_bytes = bytes_values.iter().any(|b| !b.is_empty());
        assert!(has_empty_bytes || has_non_empty_bytes, "Should generate diverse byte values");
    }

    /// Test template caching and reuse mechanisms
    #[test]
    fn test_template_caching_and_reuse_mechanisms() {
        let config = TemplateProviderConfig {
            enable_caching: true,
            cache_size_limit: 100,
            template_reuse_probability: 0.8, // High reuse probability for testing
            enable_shrinking_integration: false,
            enabled_strategies: vec![TemplateStrategy::Simplest, TemplateStrategy::CustomNamed],
        };

        let mut provider = TemplateBasedProvider::with_config(config);

        let constraints = IntegerConstraints {
            min_value: Some(0),
            max_value: Some(100),
            weights: None,
            shrink_towards: Some(0),
        };

        // Generate values to populate cache
        for _ in 0..10 {
            let _ = provider.draw_integer(&constraints).unwrap();
        }

        let stats_after_generation = provider.get_statistics();
        assert!(stats_after_generation.cache_misses > 0, "Should have cache misses");

        // Generate more values to test cache hits
        let initial_cache_hits = stats_after_generation.cache_hits;
        for _ in 0..10 {
            let _ = provider.draw_integer(&constraints).unwrap();
        }

        let stats_after_reuse = provider.get_statistics();
        assert!(stats_after_reuse.cache_hits > initial_cache_hits || stats_after_reuse.template_reuses > 0, 
                "Should have cache hits or template reuses");

        // Test cache size limit
        provider.clear_cache();
        assert_eq!(provider.get_statistics().cache_hits, 0);
        assert_eq!(provider.get_statistics().cache_misses, 0);

        // Test cache behavior with different constraint types
        let float_constraints = FloatConstraints {
            min_value: 0.0,
            max_value: 1.0,
            allow_nan: false,
            smallest_nonzero_magnitude: Some(f64::MIN_POSITIVE),
        };

        for _ in 0..5 {
            let _ = provider.draw_float(&float_constraints).unwrap();
        }

        // Should cache templates for different data types separately
        let stats = provider.get_statistics();
        assert!(stats.cache_misses > 0);

        // Test template reuse probability
        let intervals = IntervalSet::ascii();
        let reuse_count_before = provider.get_statistics().template_reuses;
        for _ in 0..20 {
            let _ = provider.draw_string(&intervals, 1, 5).unwrap();
        }
        let reuse_count_after = provider.get_statistics().template_reuses;
        assert!(reuse_count_after >= reuse_count_before, "Should reuse templates");
    }

    /// Test template-aware shrinking integration
    #[test]
    fn test_template_aware_shrinking_integration() {
        let config = TemplateProviderConfig {
            enable_caching: false, // Disable caching to focus on shrinking
            cache_size_limit: 0,
            template_reuse_probability: 0.0,
            enable_shrinking_integration: true,
            enabled_strategies: vec![
                TemplateStrategy::Simplest,
                TemplateStrategy::BiasedGeneration,
                TemplateStrategy::CustomNamed,
            ],
        };

        let mut provider = TemplateBasedProvider::with_config(config);

        let constraints = IntegerConstraints {
            min_value: Some(0),
            max_value: Some(100),
            weights: None,
            shrink_towards: Some(0),
        };

        // Test initial shrinking phase
        assert_eq!(provider.shrinking_state.current_phase, ShrinkingPhase::Initial);

        let value1 = provider.draw_integer(&constraints).unwrap();
        assert_eq!(provider.shrinking_state.current_phase, ShrinkingPhase::SimpleTemplates);

        // Test shrinking phase progression through span operations
        provider.span_start(0x12345);
        provider.span_end(true); // discard = true should advance phase

        assert_eq!(provider.shrinking_state.current_phase, ShrinkingPhase::BiasedTemplates);

        // Generate value in biased phase
        let value2 = provider.draw_integer(&constraints).unwrap();

        // Continue phase progression
        provider.span_start(0x67890);
        provider.span_end(true);
        assert_eq!(provider.shrinking_state.current_phase, ShrinkingPhase::CustomTemplates);

        let value3 = provider.draw_integer(&constraints).unwrap();

        // Continue to finalization
        provider.span_start(0xABCDE);
        provider.span_end(true);
        assert_eq!(provider.shrinking_state.current_phase, ShrinkingPhase::Finalization);

        let value4 = provider.draw_integer(&constraints).unwrap();

        // Verify shrinking integration statistics
        let stats = provider.get_statistics();
        assert!(stats.shrinking_integrations > 0, "Should track shrinking integrations");

        // Test that different phases can generate different values
        println!("Shrinking phase values: {} -> {} -> {} -> {}", value1, value2, value3, value4);

        // Test span operations don't advance phase when discard=false
        let phase_before = provider.shrinking_state.current_phase.clone();
        provider.span_start(0xFFFFF);
        provider.span_end(false); // discard = false
        assert_eq!(provider.shrinking_state.current_phase, phase_before);
    }

    /// Test template strategy selection and configuration
    #[test]
    fn test_template_strategy_selection_and_configuration() {
        // Test with only simplest strategy enabled
        let simplest_config = TemplateProviderConfig {
            enable_caching: false,
            cache_size_limit: 0,
            template_reuse_probability: 0.0,
            enable_shrinking_integration: false,
            enabled_strategies: vec![TemplateStrategy::Simplest],
        };

        let mut simplest_provider = TemplateBasedProvider::with_config(simplest_config);
        
        let constraints = IntegerConstraints {
            min_value: Some(0),
            max_value: Some(100),
            weights: None,
            shrink_towards: Some(0),
        };

        // Should generate simple values
        for _ in 0..5 {
            let value = simplest_provider.draw_integer(&constraints).unwrap();
            // Simplest templates should generate shrink_towards value (0)
            assert_eq!(value, 0);
        }

        // Test with biased strategy enabled
        let biased_config = TemplateProviderConfig {
            enable_caching: false,
            cache_size_limit: 0,
            template_reuse_probability: 0.0,
            enable_shrinking_integration: false,
            enabled_strategies: vec![TemplateStrategy::BiasedGeneration],
        };

        let mut biased_provider = TemplateBasedProvider::with_config(biased_config);

        let mut biased_values = Vec::new();
        for _ in 0..10 {
            let value = biased_provider.draw_integer(&constraints).unwrap();
            biased_values.push(value);
        }

        // Biased templates should generate diverse values based on bias
        let unique_biased: std::collections::HashSet<_> = biased_values.into_iter().collect();
        assert!(unique_biased.len() > 1, "Biased strategy should generate diverse values");

        // Test with custom named strategy
        let custom_config = TemplateProviderConfig {
            enable_caching: false,
            cache_size_limit: 0,
            template_reuse_probability: 0.0,
            enable_shrinking_integration: false,
            enabled_strategies: vec![TemplateStrategy::CustomNamed],
        };

        let mut custom_provider = TemplateBasedProvider::with_config(custom_config);

        let mut custom_values = Vec::new();
        for _ in 0..20 {
            let value = custom_provider.draw_integer(&constraints).unwrap();
            custom_values.push(value);
        }

        // Custom templates should generate specific boundary values
        let has_zero = custom_values.iter().any(|&v| v == 0);
        let has_one = custom_values.iter().any(|&v| v == 1);
        let has_boundary = custom_values.iter().any(|&v| v == 0 || v == 100); // min/max values
        assert!(has_zero || has_one || has_boundary, "Custom strategy should generate special values");

        // Test statistics tracking by strategy
        let stats = custom_provider.get_statistics();
        assert!(stats.templates_by_strategy.contains_key(&TemplateStrategy::CustomNamed),
                "Should track template usage by strategy");
    }

    /// Test provider factory registration and creation
    #[test]
    fn test_provider_factory_registration_and_creation() {
        let mut registry = ProviderRegistry::new();

        // Register template-based provider factory
        let factory = Arc::new(TemplateBasedProviderFactory::new());
        registry.register_factory(factory);

        let available = registry.available_providers();
        assert!(available.contains(&"template_based".to_string()));

        // Create provider through registry
        let provider = registry.create("template_based").unwrap();
        assert_eq!(provider.lifetime(), ProviderLifetime::TestCase);

        let capabilities = provider.capabilities();
        assert!(capabilities.supports_integers);
        assert!(capabilities.supports_floats);
        assert!(capabilities.supports_strings);
        assert!(capabilities.supports_bytes);
        assert!(capabilities.supports_choices);
        assert!(capabilities.structural_awareness);
        assert!(capabilities.replay_support);
        assert!(capabilities.add_observability_callback);

        // Test factory with custom configuration
        let custom_config = TemplateProviderConfig {
            enable_caching: true,
            cache_size_limit: 50,
            template_reuse_probability: 0.5,
            enable_shrinking_integration: true,
            enabled_strategies: vec![TemplateStrategy::Simplest, TemplateStrategy::BiasedGeneration],
        };

        let custom_factory = Arc::new(TemplateBasedProviderFactory::with_config(custom_config));
        registry.register_factory(custom_factory);

        // Should still create providers with the same name (latest registration wins)
        let custom_provider = registry.create("template_based").unwrap();
        assert_eq!(custom_provider.lifetime(), ProviderLifetime::TestCase);
    }

    /// Test complete capability integration with complex scenarios
    #[test]
    fn test_complete_capability_integration_complex_scenarios() {
        let config = TemplateProviderConfig {
            enable_caching: true,
            cache_size_limit: 200,
            template_reuse_probability: 0.4,
            enable_shrinking_integration: true,
            enabled_strategies: vec![
                TemplateStrategy::Simplest,
                TemplateStrategy::IndexBased,
                TemplateStrategy::BiasedGeneration,
                TemplateStrategy::CustomNamed,
                TemplateStrategy::StructuralAware,
                TemplateStrategy::CachedTemplates,
            ],
        };

        let mut provider = TemplateBasedProvider::with_config(config);

        // Complex scenario: Generate structured data with multiple constraint types
        let constraint_scenarios = vec![
            (ChoiceType::Integer, Constraints::Integer(IntegerConstraints {
                min_value: Some(-100),
                max_value: Some(100),
                weights: None,
                shrink_towards: Some(0),
            })),
            (ChoiceType::Boolean, Constraints::Boolean(BooleanConstraints { p: 0.7 })),
            (ChoiceType::Float, Constraints::Float(FloatConstraints {
                min_value: -10.0,
                max_value: 10.0,
                allow_nan: true,
                smallest_nonzero_magnitude: Some(1e-10),
            })),
            (ChoiceType::String, Constraints::String(StringConstraints {
                min_size: 0,
                max_size: 50,
                intervals: IntervalSet::all_characters(),
            })),
            (ChoiceType::Bytes, Constraints::Bytes(BytesConstraints {
                min_size: 0,
                max_size: 20,
            })),
        ];

        let mut generated_values = Vec::new();
        let mut phase_transitions = 0;

        // Simulate complex generation scenario with span tracking
        for iteration in 0..50 {
            let (choice_type, constraints) = &constraint_scenarios[iteration % constraint_scenarios.len()];

            // Start span for structural tracking
            provider.span_start((iteration as u32) << 16);

            // Generate value
            match provider.draw_choice(*choice_type, constraints) {
                Ok(value) => {
                    generated_values.push(value);
                    
                    // Periodically trigger shrinking phase transitions
                    if iteration % 10 == 9 {
                        provider.span_end(true); // discard = true to advance phase
                        phase_transitions += 1;
                    } else {
                        provider.span_end(false);
                    }
                }
                Err(e) => {
                    println!("Generation error at iteration {}: {}", iteration, e);
                    provider.span_end(true);
                }
            }
        }

        // Verify comprehensive generation results
        assert!(!generated_values.is_empty(), "Should generate values successfully");
        assert!(generated_values.len() >= 40, "Should generate most requested values");

        // Check for diversity in generated values
        let integer_values: Vec<_> = generated_values.iter()
            .filter_map(|v| if let ChoiceValue::Integer(i) = v { Some(*i) } else { None })
            .collect();
        let boolean_values: Vec<_> = generated_values.iter()
            .filter_map(|v| if let ChoiceValue::Boolean(b) = v { Some(*b) } else { None })
            .collect();
        let float_values: Vec<_> = generated_values.iter()
            .filter_map(|v| if let ChoiceValue::Float(f) = v { Some(*f) } else { None })
            .collect();

        assert!(!integer_values.is_empty(), "Should generate integers");
        assert!(!boolean_values.is_empty(), "Should generate booleans");
        assert!(!float_values.is_empty(), "Should generate floats");

        // Verify caching and reuse statistics
        let final_stats = provider.get_statistics();
        println!("Final statistics: Cache hits: {}, misses: {}, reuses: {}, shrinking integrations: {}",
                final_stats.cache_hits, final_stats.cache_misses, 
                final_stats.template_reuses, final_stats.shrinking_integrations);

        assert!(final_stats.cache_misses > 0, "Should have cache misses for new templates");
        assert!(final_stats.shrinking_integrations > 0, "Should track shrinking integrations");
        assert!(phase_transitions > 0, "Should have triggered phase transitions");

        // Verify strategy usage diversity
        assert!(!final_stats.templates_by_strategy.is_empty(), "Should track strategy usage");
        let total_strategy_uses: usize = final_stats.templates_by_strategy.values().sum();
        assert!(total_strategy_uses > 0, "Should use various strategies");

        // Test observability
        let observation = provider.observe_test_case();
        assert!(observation.contains_key("cache_size"));
        assert!(observation.contains_key("cache_hits"));
        assert!(observation.contains_key("template_reuses"));
        assert!(observation.contains_key("shrinking_integrations"));
        assert!(observation.contains_key("current_shrinking_phase"));

        println!("Template-based provider observation: {:?}", observation);
    }

    /// Test error handling and edge cases
    #[test]
    fn test_error_handling_and_edge_cases() {
        let mut provider = TemplateBasedProvider::new();

        // Test invalid constraint types
        let invalid_constraints = Constraints::Boolean(BooleanConstraints { p: 0.5 });
        let result = provider.draw_choice(ChoiceType::Integer, &invalid_constraints);
        assert!(result.is_err(), "Should fail with mismatched constraint types");

        // Test extreme configuration values
        let extreme_config = TemplateProviderConfig {
            enable_caching: true,
            cache_size_limit: 0, // Zero cache limit
            template_reuse_probability: 1.1, // Invalid probability (> 1.0)
            enable_shrinking_integration: true,
            enabled_strategies: vec![], // No enabled strategies
        };

        let mut extreme_provider = TemplateBasedProvider::with_config(extreme_config);

        // Should still work despite extreme configuration
        let constraints = IntegerConstraints::default();
        let result = extreme_provider.draw_integer(&constraints);
        assert!(result.is_ok(), "Should handle extreme configuration gracefully");

        // Test cache size limit enforcement
        provider.clear_cache();
        let initial_cache_size = provider.template_cache.len();
        
        // Try to generate many different constraint types to fill cache
        for i in 0..10 {
            let constraints = IntegerConstraints {
                min_value: Some(i),
                max_value: Some(i + 100),
                weights: None,
                shrink_towards: Some(i),
            };
            let _ = provider.draw_integer(&constraints);
        }

        // Verify cache behavior
        assert!(provider.template_cache.len() >= initial_cache_size);

        // Test template engine state consistency
        let initial_processed = provider.template_engine.processed_count();
        let _ = provider.draw_integer(&IntegerConstraints::default());
        assert!(provider.template_engine.processed_count() > initial_processed);
    }

    /// Test Python parity and FFI compatibility
    #[test]
    fn test_python_parity_and_ffi_compatibility() {
        let mut provider = TemplateBasedProvider::new();

        // Test that generated values follow Python Hypothesis patterns
        
        // Integer boundary testing (Python pattern)
        let boundary_constraints = IntegerConstraints {
            min_value: Some(i8::MIN as i128),
            max_value: Some(i8::MAX as i128),
            weights: None,
            shrink_towards: Some(0),
        };

        let mut boundary_values = Vec::new();
        for _ in 0..20 {
            let value = provider.draw_integer(&boundary_constraints).unwrap();
            boundary_values.push(value);
        }

        // Should occasionally generate boundary values (Python behavior)
        let has_min = boundary_values.iter().any(|&v| v == i8::MIN as i128);
        let has_max = boundary_values.iter().any(|&v| v == i8::MAX as i128);
        let has_zero = boundary_values.iter().any(|&v| v == 0);
        assert!(has_min || has_max || has_zero, "Should generate boundary values like Python");

        // Float special value testing (Python pattern)
        let float_constraints = FloatConstraints {
            min_value: f64::NEG_INFINITY,
            max_value: f64::INFINITY,
            allow_nan: true,
            smallest_nonzero_magnitude: Some(f64::MIN_POSITIVE),
        };

        let mut special_float_found = false;
        for _ in 0..30 {
            let value = provider.draw_float(&float_constraints).unwrap();
            if value.is_nan() || value.is_infinite() || value == 0.0 || value == 1.0 {
                special_float_found = true;
                break;
            }
        }
        assert!(special_float_found, "Should generate special float values like Python");

        // String edge case testing (Python pattern)
        let string_intervals = IntervalSet::ascii();
        let mut string_edge_cases = Vec::new();
        for _ in 0..15 {
            let value = provider.draw_string(&string_intervals, 0, 10).unwrap();
            string_edge_cases.push(value);
        }

        let has_empty = string_edge_cases.iter().any(|s| s.is_empty());
        let has_single_char = string_edge_cases.iter().any(|s| s.len() == 1);
        let has_whitespace = string_edge_cases.iter().any(|s| s.chars().any(|c| c.is_whitespace()));
        assert!(has_empty || has_single_char || has_whitespace, "Should generate string edge cases like Python");

        // Test serialization compatibility for FFI
        let observation = provider.observe_test_case();
        let serialized = serde_json::to_string(&observation).unwrap();
        let deserialized: HashMap<String, serde_json::Value> = serde_json::from_str(&serialized).unwrap();
        assert_eq!(observation.len(), deserialized.len(), "Should serialize/deserialize correctly for FFI");

        // Test provider metadata for FFI introspection
        let metadata = provider.metadata();
        assert!(metadata.contains_key("provider_type"));
        assert!(metadata.contains_key("lifetime"));
        assert!(metadata.contains_key("capabilities"));

        let capabilities = provider.capabilities();
        let capabilities_json = serde_json::to_value(capabilities).unwrap();
        assert!(capabilities_json.is_object(), "Capabilities should serialize for FFI");
    }
}

/// Advanced Template-Based Generation Framework
/// 
/// This framework extends the basic template-based provider with sophisticated 
/// generation strategies, performance optimization, and comprehensive template management.
#[derive(Debug)]
pub struct AdvancedTemplateGenerationFramework {
    /// Core template engine for processing templates
    template_engine: TemplateEngine,
    
    /// Template cache for efficient reuse
    template_cache: AdvancedTemplateCache,
    
    /// Structured data template registry
    structured_templates: StructuredTemplateRegistry,
    
    /// Template composition engine for nested structures
    composition_engine: TemplateCompositionEngine,
    
    /// Shrinking integration for template-aware optimization
    shrinking_integration: TemplateShrinkingIntegration,
    
    /// Performance metrics and optimization
    performance_metrics: TemplatePerformanceMetrics,
    
    /// Configuration and settings
    config: AdvancedTemplateFrameworkConfig,
}

#[derive(Debug)]
pub struct AdvancedTemplateCache {
    /// Multi-level cache storage with different eviction policies
    l1_cache: HashMap<TemplateCacheKey, ChoiceNode>, // Hot cache - frequent access
    l2_cache: HashMap<TemplateCacheKey, ChoiceNode>, // Cold cache - less frequent access
    
    /// Cache configuration
    l1_max_size: usize,
    l2_max_size: usize,
    
    /// Access tracking for cache optimization
    access_counts: HashMap<TemplateCacheKey, usize>,
    
    /// Cache statistics
    l1_hits: usize,
    l1_misses: usize,
    l2_hits: usize,
    l2_misses: usize,
    evictions: usize,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TemplateCacheKey {
    choice_type: ChoiceType,
    constraints_hash: u64,
    template_hint_hash: Option<u64>,
    context_hash: Option<u64>,
}

#[derive(Debug)]
pub struct StructuredTemplateRegistry {
    templates: HashMap<String, StructuredTemplateDefinition>,
    template_dependencies: HashMap<String, Vec<String>>,
    template_usage_stats: HashMap<String, usize>,
}

#[derive(Debug, Clone)]
pub struct StructuredTemplateDefinition {
    pub name: String,
    pub description: String,
    pub template_type: StructuredTemplateType,
    pub parameters: HashMap<String, serde_json::Value>,
    pub dependencies: Vec<String>,
    pub version: String,
}

#[derive(Debug, Clone)]
pub enum StructuredTemplateType {
    /// Simple template (no structure)
    Simple,
    
    /// Array/list template
    Array {
        element_template: Box<StructuredTemplateType>,
        min_length: usize,
        max_length: usize,
        preferred_length: Option<usize>,
    },
    
    /// Object/struct template
    Object {
        fields: Vec<(String, Box<StructuredTemplateType>)>,
        required_fields: Vec<String>,
        optional_fields: Vec<String>,
    },
    
    /// Union/choice template
    Union {
        variants: Vec<Box<StructuredTemplateType>>,
        weights: Option<Vec<f64>>,
    },
    
    /// Nested template with depth control
    Nested {
        outer_template: Box<StructuredTemplateType>,
        max_depth: usize,
        current_depth: usize,
    },
    
    /// Recursive template with cycle detection
    Recursive {
        base_case: Box<StructuredTemplateType>,
        recursive_case: Box<StructuredTemplateType>,
        max_recursion: usize,
    },
    
    /// Custom template with named generator
    Custom {
        generator_name: String,
        parameters: HashMap<String, serde_json::Value>,
    },
}

#[derive(Debug)]
pub struct TemplateCompositionEngine {
    /// Composition depth limit to prevent infinite recursion
    max_depth: usize,
    
    /// Current composition depth
    current_depth: usize,
    
    /// Cycle detection for recursive templates
    composition_stack: Vec<String>,
    
    /// Template resolution cache
    resolution_cache: HashMap<String, StructuredTemplateType>,
}

#[derive(Debug)]
pub struct TemplateShrinkingIntegration {
    /// Shrinking strategies for different template types
    shrinking_strategies: HashMap<String, ShrinkingStrategy>,
    
    /// Shrinking order preferences by choice type
    shrinking_orders: HashMap<ChoiceType, Vec<ShrinkingStrategy>>,
    
    /// Current shrinking context
    shrinking_context: ShrinkingContext,
}

#[derive(Debug, Clone)]
pub struct ShrinkingContext {
    /// Current shrinking phase
    pub current_phase: ShrinkingPhase,
    
    /// Number of shrinking attempts
    pub attempt_count: usize,
    
    /// Best shrinking result so far
    pub best_result: Option<ChoiceNode>,
    
    /// Shrinking target (what we're trying to achieve)
    pub shrinking_target: ShrinkingTarget,
}

#[derive(Debug, Clone)]
pub enum ShrinkingTarget {
    /// Shrink toward simplest possible value
    Simplest,
    
    /// Shrink toward zero/empty value
    Zero,
    
    /// Shrink toward constraint boundary
    Boundary { prefer_min: bool },
    
    /// Shrink toward specific target value
    SpecificValue(ChoiceValue),
    
    /// Shrink while preserving structure
    StructuralPreserving,
}

#[derive(Debug, Clone)]
pub enum ShrinkingStrategy {
    /// Shrink toward simplest values
    TowardsSimplest,
    
    /// Shrink toward constraint boundaries
    TowardsBoundary,
    
    /// Shrink toward zero/empty values
    TowardsZero,
    
    /// Preserve structure while shrinking content
    StructuralPreserving,
    
    /// Use binary search approach
    BinarySearch,
    
    /// Use gradient-based shrinking
    GradientBased,
    
    /// Custom shrinking strategy
    Custom { strategy_name: String },
}

#[derive(Debug, Default)]
pub struct TemplatePerformanceMetrics {
    /// Cache performance metrics
    cache_performance: CachePerformanceMetrics,
    
    /// Generation timing metrics
    generation_metrics: GenerationMetrics,
    
    /// Template usage analytics
    template_analytics: TemplateAnalytics,
    
    /// Shrinking performance metrics
    shrinking_metrics: ShrinkingMetrics,
}

#[derive(Debug, Default)]
pub struct CachePerformanceMetrics {
    l1_hits: usize,
    l1_misses: usize,
    l2_hits: usize,
    l2_misses: usize,
    evictions: usize,
    cache_size_history: Vec<(std::time::SystemTime, usize)>,
}

#[derive(Debug, Default)]
pub struct GenerationMetrics {
    total_generation_time: std::time::Duration,
    generation_count: usize,
    average_generation_time: std::time::Duration,
    generation_time_history: Vec<std::time::Duration>,
    template_generation_times: HashMap<String, std::time::Duration>,
}

#[derive(Debug, Default)]
pub struct TemplateAnalytics {
    template_usage_counts: HashMap<String, usize>,
    template_success_rates: HashMap<String, f64>,
    template_composition_counts: HashMap<String, usize>,
    most_effective_templates: Vec<(String, f64)>,
}

#[derive(Debug, Default)]
pub struct ShrinkingMetrics {
    shrinking_attempts: usize,
    successful_shrinks: usize,
    shrinking_time: std::time::Duration,
    shrinking_effectiveness: HashMap<ShrinkingStrategy, f64>,
}

#[derive(Debug, Clone)]
pub struct AdvancedTemplateFrameworkConfig {
    /// Template caching configuration
    pub cache_config: CacheConfig,
    
    /// Template generation configuration
    pub generation_config: GenerationConfig,
    
    /// Shrinking integration configuration
    pub shrinking_config: ShrinkingConfig,
    
    /// Performance optimization settings
    pub performance_config: PerformanceConfig,
    
    /// Debug and observability settings
    pub debug_config: DebugConfig,
}

#[derive(Debug, Clone)]
pub struct CacheConfig {
    pub enable_caching: bool,
    pub l1_cache_size: usize,
    pub l2_cache_size: usize,
    pub cache_eviction_policy: CacheEvictionPolicy,
    pub cache_warming_enabled: bool,
}

#[derive(Debug, Clone)]
pub enum CacheEvictionPolicy {
    LRU, // Least Recently Used
    LFU, // Least Frequently Used
    FIFO, // First In, First Out
    Random,
    TTL { ttl_seconds: u64 }, // Time To Live
}

#[derive(Debug, Clone)]
pub struct GenerationConfig {
    pub default_strategy: DefaultTemplateStrategy,
    pub enable_adaptive_strategy_selection: bool,
    pub template_diversity_factor: f64,
    pub max_generation_retries: usize,
    pub enable_template_fusion: bool,
}

#[derive(Debug, Clone)]
pub struct ShrinkingConfig {
    pub enable_shrinking_integration: bool,
    pub shrinking_strategy_order: Vec<ShrinkingStrategy>,
    pub max_shrinking_attempts: usize,
    pub shrinking_timeout: std::time::Duration,
    pub enable_parallel_shrinking: bool,
}

#[derive(Debug, Clone)]
pub struct PerformanceConfig {
    pub enable_performance_monitoring: bool,
    pub performance_sample_rate: f64,
    pub enable_template_precompilation: bool,
    pub max_concurrent_generations: usize,
}

#[derive(Debug, Clone)]
pub struct DebugConfig {
    pub enable_debug_logging: bool,
    pub log_level: DebugLogLevel,
    pub enable_template_tracing: bool,
    pub trace_sample_rate: f64,
}

#[derive(Debug, Clone)]
pub enum DebugLogLevel {
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

#[derive(Debug, Clone, PartialEq)]
pub enum DefaultTemplateStrategy {
    /// Always use simplest values
    Simplest,
    
    /// Focus on edge cases
    EdgeCases,
    
    /// Balanced approach mixing strategies
    Balanced,
    
    /// Random generation
    Random,
    
    /// Adaptive strategy based on context
    Adaptive,
    
    /// Performance-optimized strategy
    Performance,
}

impl Default for AdvancedTemplateFrameworkConfig {
    fn default() -> Self {
        Self {
            cache_config: CacheConfig {
                enable_caching: true,
                l1_cache_size: 1000,
                l2_cache_size: 5000,
                cache_eviction_policy: CacheEvictionPolicy::LRU,
                cache_warming_enabled: true,
            },
            generation_config: GenerationConfig {
                default_strategy: DefaultTemplateStrategy::Balanced,
                enable_adaptive_strategy_selection: true,
                template_diversity_factor: 0.7,
                max_generation_retries: 3,
                enable_template_fusion: true,
            },
            shrinking_config: ShrinkingConfig {
                enable_shrinking_integration: true,
                shrinking_strategy_order: vec![
                    ShrinkingStrategy::TowardsSimplest,
                    ShrinkingStrategy::TowardsZero,
                    ShrinkingStrategy::TowardsBoundary,
                    ShrinkingStrategy::StructuralPreserving,
                ],
                max_shrinking_attempts: 100,
                shrinking_timeout: std::time::Duration::from_secs(5),
                enable_parallel_shrinking: false,
            },
            performance_config: PerformanceConfig {
                enable_performance_monitoring: true,
                performance_sample_rate: 0.1,
                enable_template_precompilation: true,
                max_concurrent_generations: 4,
            },
            debug_config: DebugConfig {
                enable_debug_logging: false,
                log_level: DebugLogLevel::Info,
                enable_template_tracing: false,
                trace_sample_rate: 0.01,
            },
        }
    }
}

impl AdvancedTemplateGenerationFramework {
    /// Create a new advanced template generation framework
    pub fn new() -> Self {
        log::info!("[ADVANCED_TEMPLATE_FRAMEWORK] Initializing advanced template-based generation framework");
        
        Self {
            template_engine: TemplateEngine::new().with_debug(),
            template_cache: AdvancedTemplateCache::new(),
            structured_templates: StructuredTemplateRegistry::new(),
            composition_engine: TemplateCompositionEngine::new(),
            shrinking_integration: TemplateShrinkingIntegration::new(),
            performance_metrics: TemplatePerformanceMetrics::default(),
            config: AdvancedTemplateFrameworkConfig::default(),
        }
    }
    
    /// Create framework with custom configuration
    pub fn with_config(config: AdvancedTemplateFrameworkConfig) -> Self {
        let mut framework = Self::new();
        framework.config = config;
        
        // Apply configuration settings
        framework.template_cache.configure(&framework.config.cache_config);
        framework.composition_engine.configure(&framework.config.generation_config);
        framework.shrinking_integration.configure(&framework.config.shrinking_config);
        
        log::info!("[ADVANCED_TEMPLATE_FRAMEWORK] Framework configured with advanced settings");
        framework
    }
    
    /// Generate a choice using the advanced template-based approach
    pub fn generate_advanced_templated_choice(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        template_hint: Option<AdvancedTemplateHint>,
        generation_context: Option<GenerationContext>,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        let start_time = std::time::Instant::now();
        
        log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Generating advanced templated choice for type {:?}", choice_type);
        
        // Build cache key with context
        let cache_key = self.build_cache_key(choice_type, constraints, template_hint.as_ref(), generation_context.as_ref());
        
        // Check multi-level cache
        if let Some(cached_choice) = self.template_cache.get_cached_choice(&cache_key) {
            self.performance_metrics.cache_performance.record_hit(1);
            log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Cache hit for advanced templated choice");
            return Ok(cached_choice);
        }
        
        self.performance_metrics.cache_performance.record_miss();
        
        // Select generation strategy
        let strategy = self.select_generation_strategy(choice_type, constraints, template_hint.as_ref());
        
        // Generate choice using selected strategy
        let choice_result = match strategy {
            GenerationStrategy::Structured => {
                self.generate_structured_choice(choice_type, constraints, template_hint.as_ref())
            },
            GenerationStrategy::Composed => {
                self.generate_composed_choice(choice_type, constraints, template_hint.as_ref())
            },
            GenerationStrategy::ShrinkingOptimized => {
                self.generate_shrinking_optimized_choice(choice_type, constraints)
            },
            GenerationStrategy::Performance => {
                self.generate_performance_optimized_choice(choice_type, constraints)
            },
            GenerationStrategy::Adaptive => {
                self.generate_adaptive_choice(choice_type, constraints, template_hint.as_ref())
            },
        };
        
        match choice_result {
            Ok(choice) => {
                // Cache the generated choice
                self.template_cache.cache_choice(cache_key, choice.clone());
                
                let generation_time = start_time.elapsed();
                self.performance_metrics.generation_metrics.record_generation_time(generation_time);
                
                log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Generated advanced templated choice in {:?}", generation_time);
                Ok(choice)
            },
            Err(e) => {
                log::warn!("[ADVANCED_TEMPLATE_FRAMEWORK] Failed to generate advanced templated choice: {:?}", e);
                Err(e)
            }
        }
    }
    
    /// Build cache key with context information
    fn build_cache_key(
        &self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        template_hint: Option<&AdvancedTemplateHint>,
        generation_context: Option<&GenerationContext>,
    ) -> TemplateCacheKey {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        constraints.hash(&mut hasher);
        let constraints_hash = hasher.finish();
        
        let template_hint_hash = template_hint.map(|hint| {
            let mut hasher = DefaultHasher::new();
            hint.hash(&mut hasher);
            hasher.finish()
        });
        
        let context_hash = generation_context.map(|ctx| {
            let mut hasher = DefaultHasher::new();
            ctx.hash(&mut hasher);
            hasher.finish()
        });
        
        TemplateCacheKey {
            choice_type,
            constraints_hash,
            template_hint_hash,
            context_hash,
        }
    }
    
    /// Select optimal generation strategy based on context
    fn select_generation_strategy(
        &self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        template_hint: Option<&AdvancedTemplateHint>,
    ) -> GenerationStrategy {
        if !self.config.generation_config.enable_adaptive_strategy_selection {
            return match self.config.generation_config.default_strategy {
                DefaultTemplateStrategy::Simplest => GenerationStrategy::Structured,
                DefaultTemplateStrategy::EdgeCases => GenerationStrategy::Structured,
                DefaultTemplateStrategy::Balanced => GenerationStrategy::Composed,
                DefaultTemplateStrategy::Random => GenerationStrategy::Structured,
                DefaultTemplateStrategy::Adaptive => GenerationStrategy::Adaptive,
                DefaultTemplateStrategy::Performance => GenerationStrategy::Performance,
            };
        }
        
        // Adaptive strategy selection based on multiple factors
        let complexity_score = self.calculate_complexity_score(choice_type, constraints);
        let performance_score = self.calculate_performance_score(choice_type);
        let hint_preference = template_hint.map(|h| h.preferred_strategy()).unwrap_or(GenerationStrategy::Structured);
        
        // Weighted decision making
        if complexity_score > 0.8 {
            GenerationStrategy::Composed
        } else if performance_score < 0.3 {
            GenerationStrategy::Performance
        } else if self.should_use_shrinking_optimization() {
            GenerationStrategy::ShrinkingOptimized
        } else {
            hint_preference
        }
    }
    
    /// Calculate complexity score for adaptive strategy selection
    fn calculate_complexity_score(&self, choice_type: ChoiceType, constraints: &Constraints) -> f64 {
        let mut score = 0.0;
        
        // Base complexity by choice type
        score += match choice_type {
            ChoiceType::Integer | ChoiceType::Boolean => 0.1,
            ChoiceType::Float => 0.3,
            ChoiceType::String => 0.5,
            ChoiceType::Bytes => 0.4,
        };
        
        // Constraint complexity
        match constraints {
            Constraints::Integer(c) => {
                if c.weights.is_some() { score += 0.2; }
                if c.min_value.is_some() && c.max_value.is_some() { score += 0.1; }
            },
            Constraints::Float(c) => {
                if c.allow_nan { score += 0.2; }
                if c.smallest_nonzero_magnitude.is_some() { score += 0.1; }
            },
            Constraints::String(c) => {
                score += (c.max_size as f64 / 1000.0).min(0.3);
                if !c.intervals.intervals.is_empty() { score += 0.1; }
            },
            Constraints::Bytes(c) => {
                score += (c.max_size as f64 / 1000.0).min(0.3);
            },
            _ => {},
        }
        
        score.min(1.0)
    }
    
    /// Calculate performance score for strategy selection
    fn calculate_performance_score(&self, choice_type: ChoiceType) -> f64 {
        // Base performance score from historical data
        let base_score = 0.5;
        
        // Adjust based on template analytics
        if let Some(analytics) = self.performance_metrics.template_analytics.template_success_rates.get(&format!("{:?}", choice_type)) {
            *analytics
        } else {
            base_score
        }
    }
    
    /// Determine if shrinking optimization should be used
    fn should_use_shrinking_optimization(&self) -> bool {
        self.config.shrinking_config.enable_shrinking_integration &&
        self.shrinking_integration.shrinking_context.attempt_count > 0
    }
    
    /// Generate structured choice using registered templates
    fn generate_structured_choice(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        template_hint: Option<&AdvancedTemplateHint>,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Generating structured choice");
        
        if let Some(AdvancedTemplateHint::Structured { template_name, parameters }) = template_hint {
            let template_def = self.structured_templates.get_template(template_name)
                .ok_or_else(|| AdvancedTemplateFrameworkError::UnknownStructuredTemplate(template_name.clone()))?;
            
            let effective_template = if !parameters.is_empty() {
                template_def.with_parameters(parameters)?
            } else {
                template_def.clone()
            };
            
            self.composition_engine.generate_from_structured_template(
                choice_type,
                constraints,
                &effective_template,
            )
        } else {
            // Use default structured generation
            self.template_engine.generate_simplest_choice(choice_type, constraints)
                .map_err(AdvancedTemplateFrameworkError::TemplateError)
        }
    }
    
    /// Generate composed choice using template composition
    fn generate_composed_choice(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        template_hint: Option<&AdvancedTemplateHint>,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Generating composed choice");
        
        // Use composition engine to create complex templates
        if let Some(AdvancedTemplateHint::Composition { templates, fusion_strategy }) = template_hint {
            self.composition_engine.compose_templates(choice_type, constraints, templates, fusion_strategy)
        } else {
            // Default composition strategy
            self.composition_engine.generate_default_composition(choice_type, constraints)
        }
    }
    
    /// Generate shrinking-optimized choice
    fn generate_shrinking_optimized_choice(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Generating shrinking-optimized choice");
        
        self.shrinking_integration.generate_shrinking_optimized_choice(choice_type, constraints)
    }
    
    /// Generate performance-optimized choice
    fn generate_performance_optimized_choice(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Generating performance-optimized choice");
        
        // Use fastest available template strategy
        let template = ChoiceTemplate::simplest();
        self.template_engine.add_entry(TemplateEntry::Template(template));
        
        match self.template_engine.process_next_template(choice_type, constraints)? {
            Some(choice) => Ok(choice),
            None => Err(AdvancedTemplateFrameworkError::GenerationFailed("No template result".to_string())),
        }
    }
    
    /// Generate adaptive choice using machine learning insights
    fn generate_adaptive_choice(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        template_hint: Option<&AdvancedTemplateHint>,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        log::debug!("[ADVANCED_TEMPLATE_FRAMEWORK] Generating adaptive choice");
        
        // Analyze historical performance to select best strategy
        let best_strategy = self.analyze_best_strategy_for_context(choice_type, constraints);
        
        match best_strategy {
            GenerationStrategy::Structured => self.generate_structured_choice(choice_type, constraints, template_hint),
            GenerationStrategy::Composed => self.generate_composed_choice(choice_type, constraints, template_hint),
            GenerationStrategy::ShrinkingOptimized => self.generate_shrinking_optimized_choice(choice_type, constraints),
            GenerationStrategy::Performance => self.generate_performance_optimized_choice(choice_type, constraints),
            GenerationStrategy::Adaptive => {
                // Fallback to structured if adaptive recursion
                self.generate_structured_choice(choice_type, constraints, template_hint)
            },
        }
    }
    
    /// Analyze best strategy based on historical performance
    fn analyze_best_strategy_for_context(
        &self,
        choice_type: ChoiceType,
        constraints: &Constraints,
    ) -> GenerationStrategy {
        // Simplified strategy analysis - in real implementation this would use ML
        let context_key = format!("{:?}_{:?}", choice_type, constraints);
        
        // Default to composed strategy for complex scenarios
        if self.calculate_complexity_score(choice_type, constraints) > 0.5 {
            GenerationStrategy::Composed
        } else {
            GenerationStrategy::Structured
        }
    }
    
    /// Get comprehensive performance metrics
    pub fn get_performance_metrics(&self) -> &TemplatePerformanceMetrics {
        &self.performance_metrics
    }
    
    /// Clear all caches and reset metrics
    pub fn clear_caches(&mut self) {
        log::info!("[ADVANCED_TEMPLATE_FRAMEWORK] Clearing all caches and resetting metrics");
        self.template_cache.clear();
        self.performance_metrics = TemplatePerformanceMetrics::default();
    }
    
    /// Get comprehensive cache statistics
    pub fn get_cache_statistics(&self) -> CacheStatistics {
        self.template_cache.get_statistics()
    }
}

/// Advanced template hints for sophisticated generation control
#[derive(Debug, Clone, PartialEq)]
pub enum AdvancedTemplateHint {
    /// Use a structured template with parameters
    Structured {
        template_name: String,
        parameters: HashMap<String, serde_json::Value>,
    },
    
    /// Use template composition with fusion strategy
    Composition {
        templates: Vec<String>,
        fusion_strategy: FusionStrategy,
    },
    
    /// Use performance-optimized generation
    Performance {
        target_latency_ms: u64,
        cache_preference: CachePreference,
    },
    
    /// Use adaptive generation with learning
    Adaptive {
        learning_rate: f64,
        exploration_factor: f64,
    },
    
    /// Use custom generation strategy
    Custom {
        strategy_name: String,
        parameters: HashMap<String, serde_json::Value>,
    },
}

impl AdvancedTemplateHint {
    /// Get the preferred generation strategy for this hint
    pub fn preferred_strategy(&self) -> GenerationStrategy {
        match self {
            AdvancedTemplateHint::Structured { .. } => GenerationStrategy::Structured,
            AdvancedTemplateHint::Composition { .. } => GenerationStrategy::Composed,
            AdvancedTemplateHint::Performance { .. } => GenerationStrategy::Performance,
            AdvancedTemplateHint::Adaptive { .. } => GenerationStrategy::Adaptive,
            AdvancedTemplateHint::Custom { .. } => GenerationStrategy::Structured,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum FusionStrategy {
    /// Merge templates by combining their properties
    Merge,
    
    /// Layer templates with priority ordering
    Layer,
    
    /// Interleave template elements
    Interleave,
    
    /// Use weighted combination
    Weighted { weights: Vec<f64> },
    
    /// Use custom fusion logic
    Custom { fusion_name: String },
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CachePreference {
    /// Prefer L1 cache for fastest access
    L1Preferred,
    
    /// Prefer L2 cache for capacity
    L2Preferred,
    
    /// No cache preference
    NoPreference,
    
    /// Bypass cache entirely
    BypassCache,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenerationContext {
    /// Test case identifier
    pub test_case_id: Option<String>,
    
    /// Span hierarchy context
    pub span_context: Vec<u32>,
    
    /// Generation session id
    pub session_id: String,
    
    /// Additional context metadata
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub enum GenerationStrategy {
    Structured,
    Composed,
    ShrinkingOptimized,
    Performance,
    Adaptive,
}

#[derive(Debug, Clone)]
pub struct CacheStatistics {
    pub l1_hit_ratio: f64,
    pub l2_hit_ratio: f64,
    pub overall_hit_ratio: f64,
    pub total_requests: usize,
    pub current_l1_size: usize,
    pub current_l2_size: usize,
    pub eviction_count: usize,
}

/// Advanced template framework errors
#[derive(Debug, Clone, PartialEq)]
pub enum AdvancedTemplateFrameworkError {
    /// Template error from underlying engine
    TemplateError(TemplateError),
    
    /// Unknown structured template
    UnknownStructuredTemplate(String),
    
    /// Invalid template definition
    InvalidTemplateDefinition(String),
    
    /// Template composition failed
    CompositionFailed(String),
    
    /// Generation strategy failed
    GenerationFailed(String),
    
    /// Performance constraint violated
    PerformanceConstraintViolated(String),
    
    /// Cache operation failed
    CacheOperationFailed(String),
    
    /// Configuration error
    ConfigurationError(String),
}

impl std::fmt::Display for AdvancedTemplateFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AdvancedTemplateFrameworkError::TemplateError(e) => write!(f, "Template error: {}", e),
            AdvancedTemplateFrameworkError::UnknownStructuredTemplate(name) => {
                write!(f, "Unknown structured template: {}", name)
            },
            AdvancedTemplateFrameworkError::InvalidTemplateDefinition(msg) => {
                write!(f, "Invalid template definition: {}", msg)
            },
            AdvancedTemplateFrameworkError::CompositionFailed(msg) => {
                write!(f, "Template composition failed: {}", msg)
            },
            AdvancedTemplateFrameworkError::GenerationFailed(msg) => {
                write!(f, "Generation failed: {}", msg)
            },
            AdvancedTemplateFrameworkError::PerformanceConstraintViolated(msg) => {
                write!(f, "Performance constraint violated: {}", msg)
            },
            AdvancedTemplateFrameworkError::CacheOperationFailed(msg) => {
                write!(f, "Cache operation failed: {}", msg)
            },
            AdvancedTemplateFrameworkError::ConfigurationError(msg) => {
                write!(f, "Configuration error: {}", msg)
            },
        }
    }
}

impl std::error::Error for AdvancedTemplateFrameworkError {}

impl From<TemplateError> for AdvancedTemplateFrameworkError {
    fn from(err: TemplateError) -> Self {
        AdvancedTemplateFrameworkError::TemplateError(err)
    }
}

// Implementation stubs for the advanced components
impl AdvancedTemplateCache {
    pub fn new() -> Self {
        Self {
            l1_cache: HashMap::new(),
            l2_cache: HashMap::new(),
            l1_max_size: 1000,
            l2_max_size: 5000,
            access_counts: HashMap::new(),
            l1_hits: 0,
            l1_misses: 0,
            l2_hits: 0,
            l2_misses: 0,
            evictions: 0,
        }
    }
    
    pub fn configure(&mut self, config: &CacheConfig) {
        self.l1_max_size = config.l1_cache_size;
        self.l2_max_size = config.l2_cache_size;
    }
    
    pub fn get_cached_choice(&mut self, key: &TemplateCacheKey) -> Option<ChoiceNode> {
        // Try L1 cache first
        if let Some(choice) = self.l1_cache.get(key) {
            self.l1_hits += 1;
            *self.access_counts.entry(key.clone()).or_insert(0) += 1;
            return Some(choice.clone());
        }
        
        // Try L2 cache
        if let Some(choice) = self.l2_cache.get(key) {
            self.l2_hits += 1;
            *self.access_counts.entry(key.clone()).or_insert(0) += 1;
            
            // Promote to L1 cache
            self.promote_to_l1(key.clone(), choice.clone());
            return Some(choice.clone());
        }
        
        self.l1_misses += 1;
        None
    }
    
    pub fn cache_choice(&mut self, key: TemplateCacheKey, choice: ChoiceNode) {
        // Add to L1 cache with eviction if necessary
        if self.l1_cache.len() >= self.l1_max_size {
            self.evict_l1_entry();
        }
        
        self.l1_cache.insert(key, choice);
    }
    
    fn promote_to_l1(&mut self, key: TemplateCacheKey, choice: ChoiceNode) {
        if self.l1_cache.len() >= self.l1_max_size {
            self.evict_l1_entry();
        }
        self.l1_cache.insert(key, choice);
    }
    
    fn evict_l1_entry(&mut self) {
        if let Some((key, choice)) = self.l1_cache.iter().next().map(|(k, v)| (k.clone(), v.clone())) {
            self.l1_cache.remove(&key);
            
            // Move to L2 cache
            if self.l2_cache.len() >= self.l2_max_size {
                self.evict_l2_entry();
            }
            self.l2_cache.insert(key, choice);
            self.evictions += 1;
        }
    }
    
    fn evict_l2_entry(&mut self) {
        if let Some(key) = self.l2_cache.keys().next().cloned() {
            self.l2_cache.remove(&key);
            self.evictions += 1;
        }
    }
    
    pub fn clear(&mut self) {
        self.l1_cache.clear();
        self.l2_cache.clear();
        self.access_counts.clear();
        self.l1_hits = 0;
        self.l1_misses = 0;
        self.l2_hits = 0;
        self.l2_misses = 0;
        self.evictions = 0;
    }
    
    pub fn get_statistics(&self) -> CacheStatistics {
        let total_requests = self.l1_hits + self.l1_misses + self.l2_hits;
        let l1_hit_ratio = if total_requests > 0 { self.l1_hits as f64 / total_requests as f64 } else { 0.0 };
        let l2_hit_ratio = if total_requests > 0 { self.l2_hits as f64 / total_requests as f64 } else { 0.0 };
        let overall_hit_ratio = l1_hit_ratio + l2_hit_ratio;
        
        CacheStatistics {
            l1_hit_ratio,
            l2_hit_ratio,
            overall_hit_ratio,
            total_requests,
            current_l1_size: self.l1_cache.len(),
            current_l2_size: self.l2_cache.len(),
            eviction_count: self.evictions,
        }
    }
}

impl StructuredTemplateRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            templates: HashMap::new(),
            template_dependencies: HashMap::new(),
            template_usage_stats: HashMap::new(),
        };
        registry.register_builtin_templates();
        registry
    }
    
    fn register_builtin_templates(&mut self) {
        // Register comprehensive set of builtin templates
        let simple_template = StructuredTemplateDefinition {
            name: "simple".to_string(),
            description: "Simple template for basic generation".to_string(),
            template_type: StructuredTemplateType::Simple,
            parameters: HashMap::new(),
            dependencies: vec![],
            version: "1.0.0".to_string(),
        };
        self.templates.insert("simple".to_string(), simple_template);
        
        // More builtin templates would be added here...
    }
    
    pub fn get_template(&self, name: &str) -> Option<&StructuredTemplateDefinition> {
        self.templates.get(name)
    }
}

impl StructuredTemplateDefinition {
    pub fn with_parameters(&self, parameters: &HashMap<String, serde_json::Value>) -> Result<Self, AdvancedTemplateFrameworkError> {
        let mut new_template = self.clone();
        for (key, value) in parameters {
            new_template.parameters.insert(key.clone(), value.clone());
        }
        Ok(new_template)
    }
}

impl TemplateCompositionEngine {
    pub fn new() -> Self {
        Self {
            max_depth: 10,
            current_depth: 0,
            composition_stack: Vec::new(),
            resolution_cache: HashMap::new(),
        }
    }
    
    pub fn configure(&mut self, config: &GenerationConfig) {
        // Configure based on generation config
    }
    
    pub fn generate_from_structured_template(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        template: &StructuredTemplateDefinition,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        // Implementation would go here
        let engine = TemplateEngine::new();
        engine.generate_simplest_choice(choice_type, constraints)
            .map_err(AdvancedTemplateFrameworkError::TemplateError)
    }
    
    pub fn compose_templates(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
        templates: &[String],
        fusion_strategy: &FusionStrategy,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        // Implementation would go here
        let engine = TemplateEngine::new();
        engine.generate_simplest_choice(choice_type, constraints)
            .map_err(AdvancedTemplateFrameworkError::TemplateError)
    }
    
    pub fn generate_default_composition(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        let engine = TemplateEngine::new();
        engine.generate_simplest_choice(choice_type, constraints)
            .map_err(AdvancedTemplateFrameworkError::TemplateError)
    }
}

impl TemplateShrinkingIntegration {
    pub fn new() -> Self {
        Self {
            shrinking_strategies: HashMap::new(),
            shrinking_orders: HashMap::new(),
            shrinking_context: ShrinkingContext {
                current_phase: ShrinkingPhase::Initial,
                attempt_count: 0,
                best_result: None,
                shrinking_target: ShrinkingTarget::Simplest,
            },
        }
    }
    
    pub fn configure(&mut self, config: &ShrinkingConfig) {
        // Configure based on shrinking config
    }
    
    pub fn generate_shrinking_optimized_choice(
        &mut self,
        choice_type: ChoiceType,
        constraints: &Constraints,
    ) -> Result<ChoiceNode, AdvancedTemplateFrameworkError> {
        let engine = TemplateEngine::new();
        engine.generate_simplest_choice(choice_type, constraints)
            .map_err(AdvancedTemplateFrameworkError::TemplateError)
    }
}

impl CachePerformanceMetrics {
    pub fn record_hit(&mut self, level: u8) {
        match level {
            1 => self.l1_hits += 1,
            2 => self.l2_hits += 1,
            _ => {}
        }
    }
    
    pub fn record_miss(&mut self) {
        self.l1_misses += 1;
    }
}

impl GenerationMetrics {
    pub fn record_generation_time(&mut self, duration: std::time::Duration) {
        self.total_generation_time += duration;
        self.generation_count += 1;
        self.generation_time_history.push(duration);
        
        if self.generation_count > 0 {
            self.average_generation_time = self.total_generation_time / self.generation_count as u32;
        }
    }
}