use crate::engine_orchestrator::{EngineOrchestrator, OrchestrationResult};
use crate::data::{ConjectureResult, Status, Example};
use crate::choice::{ChoiceNode, ChoiceNodeKind, IntegerConstraints, FloatConstraints};
use crate::shrinking::ChoiceShrinker;
use crate::choice::advanced_shrinking::AdvancedShrinkingEngine;
use crate::providers::StaticProvider;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use pyo3::prelude::*;
use pyo3::types::{PyDict, PyList, PyTuple};

#[cfg(test)]
mod engine_orchestrator_choice_system_shrinking_integration_tests {
    use super::*;

    #[test]
    fn test_shrinking_integration_capability_basic_replacement() {
        // Test that ChoiceShrinker integration replaces placeholder logic
        let mut orchestrator = create_test_orchestrator();
        
        // Add a failing example with shrinkable content
        let failing_result = create_shrinkable_conjecture_result();
        orchestrator.interesting_examples.insert("test_key".to_string(), failing_result.clone());
        
        // Execute shrinking
        let result = orchestrator.shrink_interesting_examples();
        assert!(result.is_ok(), "Shrinking should succeed");
        
        // Verify placeholder logic was replaced with actual shrinking
        assert!(orchestrator.shrinks > 0, "Should have recorded shrinking attempts");
        assert!(orchestrator.shrunk_examples.contains("test_key"), "Should mark example as processed");
        
        // Verify the result was actually modified by shrinking, not just placeholder logic
        let shrunk_result = orchestrator.interesting_examples.get("test_key").unwrap();
        assert!(shrunk_result.nodes.len() <= failing_result.nodes.len(), "Should have shrunk or maintained node count");
    }

    #[test]
    fn test_conjecture_result_to_shrinking_input_conversion() {
        // Test format conversion from ConjectureResult to ChoiceShrinker input
        let conjecture_result = create_complex_conjecture_result();
        let mut shrinker = ChoiceShrinker::new(conjecture_result.clone());
        
        // Verify the shrinker can accept ConjectureResult as input
        let initial_nodes = conjecture_result.nodes.len();
        assert!(initial_nodes > 0, "Should have nodes to shrink");
        
        // Test shrinking with validation function
        let shrunk_result = shrinker.shrink(|candidate| {
            // Simulate test function validation
            validate_shrinking_candidate(&candidate)
        });
        
        // Verify successful conversion and shrinking
        assert_eq!(shrunk_result.status, conjecture_result.status);
        assert!(shrunk_result.nodes.len() <= initial_nodes, "Should maintain or reduce node count");
    }

    #[test]
    fn test_shrinking_output_to_conjecture_result_conversion() {
        // Test format conversion from shrinking output back to ConjectureResult
        let original_result = create_complex_conjecture_result();
        let mut shrinker = ChoiceShrinker::new(original_result.clone());
        
        let shrunk_result = shrinker.shrink(|candidate| {
            validate_complex_shrinking_candidate(&candidate)
        });
        
        // Verify the output maintains ConjectureResult structure
        assert!(shrunk_result.buffer.len() > 0, "Should maintain buffer");
        assert!(shrunk_result.examples.len() >= 0, "Should maintain examples structure");
        assert!(!shrunk_result.events.is_empty(), "Should maintain events");
        
        // Verify metadata preservation
        assert_eq!(shrunk_result.status, Status::Interesting);
        assert!(shrunk_result.interesting_origin.is_some(), "Should preserve failure origin");
    }

    #[test]
    fn test_orchestrator_shrinking_deadline_management() {
        // Test that shrinking respects orchestrator deadlines
        let mut orchestrator = create_test_orchestrator();
        
        // Set very short deadline
        orchestrator.finish_shrinking_deadline = Some(Instant::now() + Duration::from_millis(10));
        
        // Add multiple examples to shrink
        for i in 0..5 {
            let result = create_shrinkable_conjecture_result();
            orchestrator.interesting_examples.insert(format!("test_key_{}", i), result);
        }
        
        let start_time = Instant::now();
        let result = orchestrator.shrink_interesting_examples();
        let elapsed = start_time.elapsed();
        
        // Should respect deadline and not take too long
        assert!(result.is_ok(), "Should handle deadline gracefully");
        assert!(elapsed < Duration::from_millis(100), "Should respect deadline");
    }

    #[test]
    fn test_advanced_shrinking_engine_integration() {
        // Test integration with AdvancedShrinkingEngine for sophisticated shrinking
        let mut orchestrator = create_test_orchestrator();
        
        // Create a complex example that benefits from advanced shrinking
        let complex_result = create_advanced_shrinkable_result();
        orchestrator.interesting_examples.insert("complex_key".to_string(), complex_result.clone());
        
        // Execute shrinking
        let result = orchestrator.shrink_interesting_examples();
        assert!(result.is_ok(), "Advanced shrinking should succeed");
        
        // Verify advanced shrinking was applied
        let shrunk_result = orchestrator.interesting_examples.get("complex_key").unwrap();
        
        // Advanced shrinking should achieve better results than basic shrinking
        assert!(shrunk_result.nodes.len() < complex_result.nodes.len(), "Should achieve significant shrinking");
        assert!(shrunk_result.length < complex_result.length, "Should reduce overall length");
    }

    #[test]
    fn test_shrinking_validation_with_test_function() {
        // Test that shrinking properly validates candidates with test function
        let mut orchestrator = create_test_orchestrator();
        
        // Create a result that should shrink but maintain interesting status
        let interesting_result = create_validated_interesting_result();
        orchestrator.interesting_examples.insert("validated_key".to_string(), interesting_result.clone());
        
        // Execute shrinking with validation
        let result = orchestrator.shrink_interesting_examples();
        assert!(result.is_ok(), "Validated shrinking should succeed");
        
        // Verify the shrunk result is still interesting
        let shrunk_result = orchestrator.interesting_examples.get("validated_key").unwrap();
        assert_eq!(shrunk_result.status, Status::Interesting, "Should maintain interesting status");
        
        // Verify shrinking actually occurred
        assert!(orchestrator.shrinks > 0, "Should have successful shrinks");
    }

    #[test]
    fn test_multiple_examples_shrinking_coordination() {
        // Test shrinking coordination across multiple interesting examples
        let mut orchestrator = create_test_orchestrator();
        
        // Add multiple different types of interesting examples
        let integer_result = create_integer_shrinking_result();
        let float_result = create_float_shrinking_result();
        let string_result = create_string_shrinking_result();
        
        orchestrator.interesting_examples.insert("integer_example".to_string(), integer_result);
        orchestrator.interesting_examples.insert("float_example".to_string(), float_result);
        orchestrator.interesting_examples.insert("string_example".to_string(), string_result);
        
        // Execute coordinated shrinking
        let result = orchestrator.shrink_interesting_examples();
        assert!(result.is_ok(), "Multi-example shrinking should succeed");
        
        // Verify all examples were processed
        assert_eq!(orchestrator.shrunk_examples.len(), 3, "Should process all examples");
        assert!(orchestrator.shrinks >= 3, "Should attempt shrinking for each example");
        
        // Verify each type was handled appropriately
        assert!(orchestrator.interesting_examples.contains_key("integer_example"));
        assert!(orchestrator.interesting_examples.contains_key("float_example"));
        assert!(orchestrator.interesting_examples.contains_key("string_example"));
    }

    #[test]
    fn test_shrinking_error_handling_and_recovery() {
        // Test error handling during shrinking integration
        let mut orchestrator = create_test_orchestrator();
        
        // Add an example that might cause shrinking errors
        let problematic_result = create_problematic_shrinking_result();
        orchestrator.interesting_examples.insert("problematic_key".to_string(), problematic_result);
        
        // Execute shrinking - should handle errors gracefully
        let result = orchestrator.shrink_interesting_examples();
        
        // Should not crash even with problematic inputs
        match result {
            Ok(_) => {
                // If successful, verify state is consistent
                assert!(orchestrator.shrunk_examples.len() > 0, "Should track processing attempts");
            }
            Err(e) => {
                // If error, should be handled gracefully
                eprintln!("Shrinking error handled: {:?}", e);
                assert!(true, "Error handling should be graceful");
            }
        }
    }

    #[test]
    fn test_shrinking_performance_metrics_integration() {
        // Test integration with orchestrator's performance tracking
        let mut orchestrator = create_test_orchestrator();
        
        // Add examples with different shrinking complexity
        let simple_result = create_simple_shrinking_result();
        let complex_result = create_complex_shrinking_result();
        
        orchestrator.interesting_examples.insert("simple".to_string(), simple_result);
        orchestrator.interesting_examples.insert("complex".to_string(), complex_result);
        
        let start_time = Instant::now();
        let result = orchestrator.shrink_interesting_examples();
        let elapsed = start_time.elapsed();
        
        assert!(result.is_ok(), "Performance tracking should not interfere");
        
        // Verify metrics are updated
        assert!(orchestrator.shrinks > 0, "Should track shrinking attempts");
        assert!(elapsed > Duration::from_nanos(1), "Should measure actual time");
        
        // Performance should be reasonable
        assert!(elapsed < Duration::from_secs(5), "Should complete in reasonable time");
    }

    #[pyfunction]
    fn test_pyo3_shrinking_integration_wrapper() -> PyResult<()> {
        // PyO3 wrapper test for shrinking integration capability
        Python::with_gil(|py| {
            let orchestrator = create_test_orchestrator();
            
            // Convert orchestrator state to Python-accessible format
            let py_dict = PyDict::new(py);
            py_dict.set_item("interesting_count", orchestrator.interesting_examples.len())?;
            py_dict.set_item("shrunk_count", orchestrator.shrunk_examples.len())?;
            py_dict.set_item("shrink_attempts", orchestrator.shrinks)?;
            
            // Test Python can access shrinking state
            let interesting_count: usize = py_dict.get_item("interesting_count")
                .unwrap()
                .extract()?;
            
            assert_eq!(interesting_count, 0, "Initial state should be empty");
            Ok(())
        })
    }

    #[test]
    fn test_ffi_shrinking_capability_export() {
        // Test FFI export of shrinking integration capability
        let mut orchestrator = create_test_orchestrator();
        
        // Add test data
        let test_result = create_shrinkable_conjecture_result();
        orchestrator.interesting_examples.insert("ffi_test".to_string(), test_result);
        
        // Simulate FFI call to shrinking capability
        let result = orchestrator.shrink_interesting_examples();
        assert!(result.is_ok(), "FFI shrinking should succeed");
        
        // Verify FFI-accessible state
        let shrink_count = orchestrator.shrinks;
        let processed_count = orchestrator.shrunk_examples.len();
        
        assert!(shrink_count > 0, "FFI should expose shrink attempts");
        assert!(processed_count > 0, "FFI should expose processing count");
    }

    // Helper functions for test setup

    fn create_test_orchestrator() -> EngineOrchestrator {
        let provider = StaticProvider::new();
        EngineOrchestrator::new(Box::new(provider))
    }

    fn create_shrinkable_conjecture_result() -> ConjectureResult {
        let mut nodes = Vec::new();
        
        // Add integer nodes that can be shrunk
        for i in 0..5 {
            nodes.push(ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(0),
                    max: Some(100),
                    ..Default::default()
                }),
                value: (10 + i).into(),
                metadata: Default::default(),
            });
        }
        
        ConjectureResult {
            status: Status::Interesting,
            nodes,
            length: 20,
            events: HashMap::from([("failure".to_string(), "test_failure".to_string())]),
            buffer: vec![1, 2, 3, 4, 5],
            examples: vec![Example {
                start: 0,
                end: 5,
                depth: 0,
                label: "test_example".to_string(),
            }],
            interesting_origin: Some("test_failure".to_string()),
            ..Default::default()
        }
    }

    fn create_complex_conjecture_result() -> ConjectureResult {
        let mut nodes = Vec::new();
        
        // Mix of different constraint types for complex shrinking
        nodes.push(ChoiceNode {
            kind: ChoiceNodeKind::Integer(IntegerConstraints {
                min: Some(0),
                max: Some(1000),
                ..Default::default()
            }),
            value: 500.into(),
            metadata: Default::default(),
        });
        
        nodes.push(ChoiceNode {
            kind: ChoiceNodeKind::Float(FloatConstraints {
                min_value: Some(0.0),
                max_value: Some(100.0),
                allow_nan: false,
                allow_infinity: false,
                ..Default::default()
            }),
            value: 50.5.into(),
            metadata: Default::default(),
        });
        
        ConjectureResult {
            status: Status::Interesting,
            nodes,
            length: 50,
            events: HashMap::from([
                ("complex_failure".to_string(), "multi_constraint".to_string()),
                ("type".to_string(), "complex".to_string()),
            ]),
            buffer: vec![1; 50],
            examples: vec![
                Example { start: 0, end: 25, depth: 0, label: "integer_part".to_string() },
                Example { start: 25, end: 50, depth: 1, label: "float_part".to_string() },
            ],
            interesting_origin: Some("complex_constraint_failure".to_string()),
            ..Default::default()
        }
    }

    fn create_advanced_shrinkable_result() -> ConjectureResult {
        let mut nodes = Vec::new();
        
        // Create complex pattern that benefits from advanced shrinking
        for i in 0..10 {
            nodes.push(ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(0),
                    max: Some(1000),
                    ..Default::default()
                }),
                value: (100 * (i + 1)).into(),
                metadata: Default::default(),
            });
        }
        
        ConjectureResult {
            status: Status::Interesting,
            nodes,
            length: 100,
            events: HashMap::from([("advanced_pattern".to_string(), "detected".to_string())]),
            buffer: vec![1; 100],
            examples: vec![Example {
                start: 0,
                end: 100,
                depth: 0,
                label: "advanced_example".to_string(),
            }],
            interesting_origin: Some("advanced_shrinking_test".to_string()),
            ..Default::default()
        }
    }

    fn create_validated_interesting_result() -> ConjectureResult {
        ConjectureResult {
            status: Status::Interesting,
            nodes: vec![ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(1),
                    max: Some(10),
                    ..Default::default()
                }),
                value: 5.into(),
                metadata: Default::default(),
            }],
            length: 10,
            events: HashMap::from([("validated".to_string(), "true".to_string())]),
            buffer: vec![5],
            examples: vec![Example {
                start: 0,
                end: 1,
                depth: 0,
                label: "validated_example".to_string(),
            }],
            interesting_origin: Some("validation_test".to_string()),
            ..Default::default()
        }
    }

    fn create_integer_shrinking_result() -> ConjectureResult {
        ConjectureResult {
            status: Status::Interesting,
            nodes: vec![ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(0),
                    max: Some(1000),
                    ..Default::default()
                }),
                value: 999.into(),
                metadata: Default::default(),
            }],
            length: 4,
            events: HashMap::from([("type".to_string(), "integer".to_string())]),
            buffer: vec![255, 255, 3, 231],
            examples: vec![Example {
                start: 0,
                end: 4,
                depth: 0,
                label: "integer_example".to_string(),
            }],
            interesting_origin: Some("integer_test".to_string()),
            ..Default::default()
        }
    }

    fn create_float_shrinking_result() -> ConjectureResult {
        ConjectureResult {
            status: Status::Interesting,
            nodes: vec![ChoiceNode {
                kind: ChoiceNodeKind::Float(FloatConstraints {
                    min_value: Some(0.0),
                    max_value: Some(1000.0),
                    allow_nan: false,
                    allow_infinity: false,
                    ..Default::default()
                }),
                value: 999.999.into(),
                metadata: Default::default(),
            }],
            length: 8,
            events: HashMap::from([("type".to_string(), "float".to_string())]),
            buffer: vec![64, 143, 255, 223, 255, 174, 71, 174],
            examples: vec![Example {
                start: 0,
                end: 8,
                depth: 0,
                label: "float_example".to_string(),
            }],
            interesting_origin: Some("float_test".to_string()),
            ..Default::default()
        }
    }

    fn create_string_shrinking_result() -> ConjectureResult {
        ConjectureResult {
            status: Status::Interesting,
            nodes: vec![ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(65),  // 'A'
                    max: Some(90),  // 'Z'
                    ..Default::default()
                }),
                value: 75.into(),  // 'K'
                metadata: Default::default(),
            }],
            length: 10,
            events: HashMap::from([("type".to_string(), "string".to_string())]),
            buffer: b"KKKKKKKKKK".to_vec(),
            examples: vec![Example {
                start: 0,
                end: 10,
                depth: 0,
                label: "string_example".to_string(),
            }],
            interesting_origin: Some("string_test".to_string()),
            ..Default::default()
        }
    }

    fn create_problematic_shrinking_result() -> ConjectureResult {
        ConjectureResult {
            status: Status::Interesting,
            nodes: vec![ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(i64::MAX),  // Problematic constraints
                    max: Some(i64::MIN),
                    ..Default::default()
                }),
                value: 0.into(),
                metadata: Default::default(),
            }],
            length: 1,
            events: HashMap::from([("type".to_string(), "problematic".to_string())]),
            buffer: vec![0],
            examples: vec![],
            interesting_origin: Some("error_test".to_string()),
            ..Default::default()
        }
    }

    fn create_simple_shrinking_result() -> ConjectureResult {
        ConjectureResult {
            status: Status::Interesting,
            nodes: vec![ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(0),
                    max: Some(10),
                    ..Default::default()
                }),
                value: 5.into(),
                metadata: Default::default(),
            }],
            length: 1,
            events: HashMap::from([("complexity".to_string(), "simple".to_string())]),
            buffer: vec![5],
            examples: vec![Example {
                start: 0,
                end: 1,
                depth: 0,
                label: "simple".to_string(),
            }],
            interesting_origin: Some("simple_test".to_string()),
            ..Default::default()
        }
    }

    fn create_complex_shrinking_result() -> ConjectureResult {
        let mut nodes = Vec::new();
        for i in 0..20 {
            nodes.push(ChoiceNode {
                kind: ChoiceNodeKind::Integer(IntegerConstraints {
                    min: Some(0),
                    max: Some(1000000),
                    ..Default::default()
                }),
                value: (i * 50000).into(),
                metadata: Default::default(),
            });
        }
        
        ConjectureResult {
            status: Status::Interesting,
            nodes,
            length: 200,
            events: HashMap::from([("complexity".to_string(), "complex".to_string())]),
            buffer: vec![1; 200],
            examples: vec![Example {
                start: 0,
                end: 200,
                depth: 0,
                label: "complex".to_string(),
            }],
            interesting_origin: Some("complex_test".to_string()),
            ..Default::default()
        }
    }

    // Validation functions for shrinking candidates

    fn validate_shrinking_candidate(candidate: &ConjectureResult) -> bool {
        // Basic validation - ensure candidate maintains interesting properties
        candidate.status == Status::Interesting && 
        !candidate.nodes.is_empty() &&
        candidate.interesting_origin.is_some()
    }

    fn validate_complex_shrinking_candidate(candidate: &ConjectureResult) -> bool {
        // Complex validation with multiple constraints
        if candidate.status != Status::Interesting {
            return false;
        }
        
        // Ensure structural integrity
        if candidate.nodes.is_empty() || candidate.buffer.is_empty() {
            return false;
        }
        
        // Validate constraint satisfaction
        for node in &candidate.nodes {
            match &node.kind {
                ChoiceNodeKind::Integer(constraints) => {
                    if let Some(min) = constraints.min {
                        if node.value.as_i64().unwrap_or(0) < min {
                            return false;
                        }
                    }
                    if let Some(max) = constraints.max {
                        if node.value.as_i64().unwrap_or(0) > max {
                            return false;
                        }
                    }
                }
                ChoiceNodeKind::Float(constraints) => {
                    if let Some(min) = constraints.min_value {
                        if node.value.as_f64().unwrap_or(0.0) < min {
                            return false;
                        }
                    }
                    if let Some(max) = constraints.max_value {
                        if node.value.as_f64().unwrap_or(0.0) > max {
                            return false;
                        }
                    }
                }
                _ => {}
            }
        }
        
        true
    }
}