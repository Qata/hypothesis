//! Comprehensive tests for the Targeting System & Coverage-Guided Generation capability
//! 
//! Tests the complete targeting capability's behavior including:
//! - Pareto frontier optimization for multi-objective targeting
//! - Coverage-guided test case generation  
//! - Target function implementations (minimize, maximize, etc.)
//! - Target observation collection and analysis
//! - Integration with ChoiceSystem for guided selection

use crate::choice::{ChoiceType};
use crate::data::ConjectureData;
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};

/// Target observation for tracking optimization objectives
#[derive(Debug, Clone, PartialEq)]
pub struct TargetObservation {
    pub value: f64,
    pub label: String,
    pub metadata: HashMap<String, String>,
}

/// Multi-objective optimization point on Pareto frontier
#[derive(Debug, Clone)]
pub struct ParetoPoint {
    pub objectives: Vec<f64>,
    pub test_case: Vec<u8>,
    pub observations: Vec<TargetObservation>,
}

/// Coverage-guided generation state
#[derive(Debug, Clone)]
pub struct CoverageState {
    pub covered_branches: HashSet<String>,
    pub branch_counts: HashMap<String, u32>,
    pub interesting_regions: Vec<Vec<u8>>,
}

/// Target function for optimization
pub trait TargetFunction: Send + Sync {
    fn evaluate(&self, data: &ConjectureData) -> f64;
    fn label(&self) -> &str;
    fn direction(&self) -> OptimizationDirection;
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum OptimizationDirection {
    Minimize,
    Maximize,
}

/// Pareto frontier maintenance for multi-objective optimization
pub struct ParetoFrontier {
    points: Vec<ParetoPoint>,
    max_size: usize,
}

impl ParetoFrontier {
    pub fn new(max_size: usize) -> Self {
        Self {
            points: Vec::new(),
            max_size,
        }
    }

    pub fn add_point(&mut self, point: ParetoPoint) -> bool {
        // Check if dominated by existing points
        let is_dominated = self.points.iter().any(|existing| {
            self.dominates(&existing.objectives, &point.objectives)
        });

        if is_dominated {
            return false;
        }

        // Remove dominated points
        let new_objectives = point.objectives.clone();
        self.points.retain(|existing| {
            !ParetoFrontier::dominates_static(&new_objectives, &existing.objectives)
        });

        self.points.push(point);

        // Maintain size limit
        if self.points.len() > self.max_size {
            // Remove least diverse point
            self.points.sort_by(|a, b| {
                a.objectives.iter().sum::<f64>()
                    .partial_cmp(&b.objectives.iter().sum::<f64>())
                    .unwrap_or(std::cmp::Ordering::Equal)
            });
            self.points.pop();
        }

        true
    }

    fn dominates_static(a: &[f64], b: &[f64]) -> bool {
        if a.len() != b.len() {
            return false;
        }
        
        let mut better_in_any = false;
        for (a_val, b_val) in a.iter().zip(b.iter()) {
            if a_val > b_val {
                return false; // Worse in this objective
            }
            if a_val < b_val {
                better_in_any = true; // Better in this objective
            }
        }
        better_in_any
    }

    fn dominates(&self, a: &[f64], b: &[f64]) -> bool {
        assert_eq!(a.len(), b.len());
        let mut at_least_one_better = false;
        for (av, bv) in a.iter().zip(b.iter()) {
            if av > bv {
                return false;
            }
            if av < bv {
                at_least_one_better = true;
            }
        }
        at_least_one_better
    }

    pub fn points(&self) -> &[ParetoPoint] {
        &self.points
    }
}

/// Coverage-guided generation system
pub struct CoverageGuidedGenerator {
    coverage: Arc<Mutex<CoverageState>>,
    interesting_threshold: f64,
}

impl CoverageGuidedGenerator {
    pub fn new(interesting_threshold: f64) -> Self {
        Self {
            coverage: Arc::new(Mutex::new(CoverageState {
                covered_branches: HashSet::new(),
                branch_counts: HashMap::new(),
                interesting_regions: Vec::new(),
            })),
            interesting_threshold,
        }
    }

    pub fn observe_coverage(&self, branch: String, test_case: Vec<u8>) {
        let mut coverage = self.coverage.lock().unwrap();
        
        // Check if this is new coverage before modifying counts
        let is_new_coverage = !coverage.covered_branches.contains(&branch);
        
        // Update count
        let count = coverage.branch_counts.entry(branch.clone()).or_insert(0);
        *count += 1;
        let current_count = *count;

        if is_new_coverage {
            coverage.covered_branches.insert(branch);
            // New coverage is always interesting
            if coverage.interesting_regions.len() < 1000 {
                coverage.interesting_regions.push(test_case);
            }
        } else if (current_count as f64) < self.interesting_threshold {
            // Rare branches are interesting
            if coverage.interesting_regions.len() < 1000 {
                coverage.interesting_regions.push(test_case);
            }
        }
    }

    pub fn get_interesting_seed(&self) -> Option<Vec<u8>> {
        let coverage = self.coverage.lock().unwrap();
        if coverage.interesting_regions.is_empty() {
            None
        } else {
            let idx = rand::random::<usize>() % coverage.interesting_regions.len();
            Some(coverage.interesting_regions[idx].clone())
        }
    }

    pub fn coverage_stats(&self) -> (usize, usize) {
        let coverage = self.coverage.lock().unwrap();
        (coverage.covered_branches.len(), coverage.interesting_regions.len())
    }
}

/// Main targeting system
pub struct TargetingSystem {
    pareto_frontier: Arc<Mutex<ParetoFrontier>>,
    coverage_generator: Arc<CoverageGuidedGenerator>,
    target_functions: Vec<Arc<dyn TargetFunction>>,
    observations: Arc<Mutex<Vec<TargetObservation>>>,
}

impl TargetingSystem {
    pub fn new(max_pareto_size: usize, coverage_threshold: f64) -> Self {
        Self {
            pareto_frontier: Arc::new(Mutex::new(ParetoFrontier::new(max_pareto_size))),
            coverage_generator: Arc::new(CoverageGuidedGenerator::new(coverage_threshold)),
            target_functions: Vec::new(),
            observations: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub fn add_target_function(&mut self, func: Arc<dyn TargetFunction>) {
        self.target_functions.push(func);
    }

    pub fn observe(&self, observation: TargetObservation) {
        let mut observations = self.observations.lock().unwrap();
        observations.push(observation);
    }

    pub fn evaluate_and_update(&self, data: &ConjectureData, test_case: Vec<u8>) -> Vec<f64> {
        let objectives: Vec<f64> = self.target_functions
            .iter()
            .map(|func| func.evaluate(data))
            .collect();

        if !objectives.is_empty() {
            let observations: Vec<TargetObservation> = self.target_functions
                .iter()
                .zip(objectives.iter())
                .map(|(func, &value)| TargetObservation {
                    value,
                    label: func.label().to_string(),
                    metadata: HashMap::new(),
                })
                .collect();

            let point = ParetoPoint {
                objectives: objectives.clone(),
                test_case: test_case.clone(),
                observations,
            };

            let mut frontier = self.pareto_frontier.lock().unwrap();
            frontier.add_point(point);
        }

        objectives
    }

    pub fn get_pareto_points(&self) -> Vec<ParetoPoint> {
        let frontier = self.pareto_frontier.lock().unwrap();
        frontier.points().to_vec()
    }

    pub fn get_observations(&self) -> Vec<TargetObservation> {
        let observations = self.observations.lock().unwrap();
        observations.clone()
    }

    pub fn coverage_generator(&self) -> &CoverageGuidedGenerator {
        &self.coverage_generator
    }
}

// Built-in target functions
pub struct MinimizeTarget {
    label: String,
}

impl MinimizeTarget {
    pub fn new(label: String) -> Self {
        Self { label }
    }
}

impl TargetFunction for MinimizeTarget {
    fn evaluate(&self, data: &ConjectureData) -> f64 {
        // Simple heuristic: minimize total bytes consumed
        data.buffer.len() as f64
    }

    fn label(&self) -> &str {
        &self.label
    }

    fn direction(&self) -> OptimizationDirection {
        OptimizationDirection::Minimize
    }
}

pub struct MaximizeTarget {
    label: String,
}

impl MaximizeTarget {
    pub fn new(label: String) -> Self {
        Self { label }
    }
}

impl TargetFunction for MaximizeTarget {
    fn evaluate(&self, data: &ConjectureData) -> f64 {
        // Simple heuristic: maximize unique bytes
        let mut unique_bytes = HashSet::new();
        for &byte in &data.buffer {
            unique_bytes.insert(byte);
        }
        unique_bytes.len() as f64
    }

    fn label(&self) -> &str {
        &self.label
    }

    fn direction(&self) -> OptimizationDirection {
        OptimizationDirection::Maximize
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pareto_frontier_basic() {
        let mut frontier = ParetoFrontier::new(10);
        
        // Add first point
        let point1 = ParetoPoint {
            objectives: vec![1.0, 2.0],
            test_case: vec![1, 2, 3],
            observations: vec![],
        };
        assert!(frontier.add_point(point1));
        assert_eq!(frontier.points().len(), 1);

        // Add dominated point (should be rejected)
        let point2 = ParetoPoint {
            objectives: vec![2.0, 3.0],
            test_case: vec![2, 3, 4],
            observations: vec![],
        };
        assert!(!frontier.add_point(point2));
        assert_eq!(frontier.points().len(), 1);

        // Add non-dominated point
        let point3 = ParetoPoint {
            objectives: vec![0.5, 3.0],
            test_case: vec![3, 4, 5],
            observations: vec![],
        };
        assert!(frontier.add_point(point3));
        assert_eq!(frontier.points().len(), 2);
    }

    #[test]
    fn test_pareto_frontier_domination() {
        let mut frontier = ParetoFrontier::new(10);

        // Add baseline point
        let point1 = ParetoPoint {
            objectives: vec![2.0, 2.0],
            test_case: vec![1],
            observations: vec![],
        };
        frontier.add_point(point1);

        // This point dominates the first one
        let point2 = ParetoPoint {
            objectives: vec![1.0, 1.0],
            test_case: vec![2],
            observations: vec![],
        };
        assert!(frontier.add_point(point2));
        assert_eq!(frontier.points().len(), 1);
        assert_eq!(frontier.points()[0].objectives, vec![1.0, 1.0]);
    }

    #[test]
    fn test_coverage_guided_generator() {
        let generator = CoverageGuidedGenerator::new(5.0);
        
        // Initial state
        let (branches, regions) = generator.coverage_stats();
        assert_eq!(branches, 0);
        assert_eq!(regions, 0);
        
        // Observe new coverage
        generator.observe_coverage("branch1".to_string(), vec![1, 2, 3]);
        let (branches, regions) = generator.coverage_stats();
        assert_eq!(branches, 1);
        assert_eq!(regions, 1);
        
        // Same branch again (should not add to interesting regions immediately)
        generator.observe_coverage("branch1".to_string(), vec![4, 5, 6]);
        let (branches, regions) = generator.coverage_stats();
        assert_eq!(branches, 1);
        assert_eq!(regions, 1);
        
        // New branch
        generator.observe_coverage("branch2".to_string(), vec![7, 8, 9]);
        let (branches, regions) = generator.coverage_stats();
        assert_eq!(branches, 2);
        assert_eq!(regions, 2);
    }

    #[test]
    fn test_targeting_system_integration() {
        let mut system = TargetingSystem::new(5, 3.0);
        
        // Add target functions
        system.add_target_function(Arc::new(MinimizeTarget::new("minimize".to_string())));
        system.add_target_function(Arc::new(MaximizeTarget::new("maximize".to_string())));
        
        // Create test data
        let mut data = ConjectureData::for_buffer(vec![1, 2, 3, 4, 5]);
        
        // Evaluate and update
        let objectives = system.evaluate_and_update(&data, vec![1, 2, 3, 4, 5]);
        assert_eq!(objectives.len(), 2);
        
        // Check Pareto points
        let points = system.get_pareto_points();
        assert_eq!(points.len(), 1);
        assert_eq!(points[0].objectives, objectives);
    }

    #[test]
    fn test_target_observation() {
        let observation = TargetObservation {
            value: 42.0,
            label: "test_metric".to_string(),
            metadata: {
                let mut map = HashMap::new();
                map.insert("type".to_string(), "performance".to_string());
                map
            },
        };
        
        assert_eq!(observation.value, 42.0);
        assert_eq!(observation.label, "test_metric");
        assert_eq!(observation.metadata.get("type").unwrap(), "performance");
    }

    #[test]
    fn test_minimize_target_function() {
        let target = MinimizeTarget::new("minimize_size".to_string());
        let data = ConjectureData::for_buffer(vec![1, 2, 3]);
        
        let value = target.evaluate(&data);
        assert_eq!(value, 3.0);
        assert_eq!(target.label(), "minimize_size");
        assert_eq!(target.direction(), OptimizationDirection::Minimize);
    }

    #[test]
    fn test_maximize_target_function() {
        let target = MaximizeTarget::new("maximize_diversity".to_string());
        let data = ConjectureData::for_buffer(vec![1, 1, 2, 2, 3]);
        
        let value = target.evaluate(&data);
        assert_eq!(value, 3.0); // 3 unique bytes
        assert_eq!(target.label(), "maximize_diversity");
        assert_eq!(target.direction(), OptimizationDirection::Maximize);
    }

    #[test]
    fn test_multi_objective_optimization() {
        let mut system = TargetingSystem::new(10, 2.0);
        
        system.add_target_function(Arc::new(MinimizeTarget::new("size".to_string())));
        system.add_target_function(Arc::new(MaximizeTarget::new("diversity".to_string())));
        
        // Test with different data points
        let test_cases = vec![
            vec![1, 1, 1], // Small, low diversity
            vec![1, 2, 3, 4, 5, 6, 7, 8], // Large, high diversity
            vec![1, 2, 3], // Medium size, medium diversity
        ];
        
        for test_case in test_cases {
            let data = ConjectureData::for_buffer(test_case.clone());
            system.evaluate_and_update(&data, test_case);
        }
        
        let points = system.get_pareto_points();
        assert!(!points.is_empty());
        
        // Verify all points are non-dominated
        for i in 0..points.len() {
            for j in 0..points.len() {
                if i != j {
                    let dominates = points[i].objectives.iter()
                        .zip(points[j].objectives.iter())
                        .all(|(a, b)| a <= b) &&
                        points[i].objectives.iter()
                        .zip(points[j].objectives.iter())
                        .any(|(a, b)| a < b);
                    assert!(!dominates, "Point {} dominates point {}", i, j);
                }
            }
        }
    }

    #[test]
    fn test_coverage_guided_interesting_seeds() {
        let generator = CoverageGuidedGenerator::new(2.0);
        
        // Add some interesting regions
        generator.observe_coverage("rare_branch".to_string(), vec![1, 2, 3]);
        generator.observe_coverage("common_branch".to_string(), vec![4, 5, 6]);
        
        // Should be able to get seeds
        let seed = generator.get_interesting_seed();
        assert!(seed.is_some());
        let seed_data = seed.unwrap();
        assert!(seed_data == vec![1, 2, 3] || seed_data == vec![4, 5, 6]);
    }

    #[test]
    fn test_targeting_system_observations() {
        let system = TargetingSystem::new(5, 1.0);
        
        let observation = TargetObservation {
            value: 3.14,
            label: "pi_approximation".to_string(),
            metadata: HashMap::new(),
        };
        
        system.observe(observation.clone());
        
        let observations = system.get_observations();
        assert_eq!(observations.len(), 1);
        assert_eq!(observations[0], observation);
    }

    #[test]
    fn test_pareto_frontier_size_limit() {
        let mut frontier = ParetoFrontier::new(2);
        
        // Add 3 non-dominated points
        let points = vec![
            ParetoPoint {
                objectives: vec![1.0, 3.0],
                test_case: vec![1],
                observations: vec![],
            },
            ParetoPoint {
                objectives: vec![2.0, 2.0],
                test_case: vec![2],
                observations: vec![],
            },
            ParetoPoint {
                objectives: vec![3.0, 1.0],
                test_case: vec![3],
                observations: vec![],
            },
        ];
        
        for point in points {
            frontier.add_point(point);
        }
        
        // Should maintain size limit
        assert_eq!(frontier.points().len(), 2);
    }

    #[test]
    fn test_coverage_generator_threshold_behavior() {
        let generator = CoverageGuidedGenerator::new(3.0);
        
        // Observe same branch multiple times
        for i in 0..5 {
            generator.observe_coverage("test_branch".to_string(), vec![i]);
        }
        
        let (branches, regions) = generator.coverage_stats();
        assert_eq!(branches, 1);
        // Should have added multiple interesting regions due to threshold
        assert!(regions >= 1);
    }

    #[test]
    fn test_targeting_system_empty_targets() {
        let system = TargetingSystem::new(5, 1.0);
        let data = ConjectureData::for_buffer(vec![1, 2, 3]);
        
        let objectives = system.evaluate_and_update(&data, vec![1, 2, 3]);
        assert!(objectives.is_empty());
        
        let points = system.get_pareto_points();
        assert!(points.is_empty());
    }

    #[test]
    fn test_optimization_direction_types() {
        assert_eq!(OptimizationDirection::Minimize, OptimizationDirection::Minimize);
        assert_eq!(OptimizationDirection::Maximize, OptimizationDirection::Maximize);
        assert_ne!(OptimizationDirection::Minimize, OptimizationDirection::Maximize);
    }
}

// PyO3 FFI Tests for Python Integration
#[cfg(test)]
mod python_ffi_tests {
    use super::*;
    use pyo3::prelude::*;
    use pyo3::types::{PyDict, PyList};

    #[test]
    fn test_python_target_observation_conversion() {
        Python::with_gil(|py| {
            let observation = TargetObservation {
                value: 42.0,
                label: "test_metric".to_string(),
                metadata: {
                    let mut map = HashMap::new();
                    map.insert("category".to_string(), "performance".to_string());
                    map
                },
            };

            // Convert to Python dict
            let py_dict = PyDict::new(py);
            py_dict.set_item("value", observation.value).unwrap();
            py_dict.set_item("label", &observation.label).unwrap();
            
            let py_metadata = PyDict::new(py);
            for (k, v) in &observation.metadata {
                py_metadata.set_item(k, v).unwrap();
            }
            py_dict.set_item("metadata", py_metadata).unwrap();

            // Verify conversion
            assert_eq!(py_dict.get_item("value").unwrap().extract::<f64>().unwrap(), 42.0);
            assert_eq!(py_dict.get_item("label").unwrap().extract::<String>().unwrap(), "test_metric");
        });
    }

    #[test]
    fn test_python_pareto_points_serialization() {
        Python::with_gil(|py| {
            let point = ParetoPoint {
                objectives: vec![1.0, 2.0, 3.0],
                test_case: vec![10, 20, 30],
                observations: vec![
                    TargetObservation {
                        value: 1.0,
                        label: "obj1".to_string(),
                        metadata: HashMap::new(),
                    },
                ],
            };

            // Convert objectives to Python list
            let py_objectives = PyList::new(py, &point.objectives);
            assert_eq!(py_objectives.len(), 3);
            assert_eq!(py_objectives.get_item(0).unwrap().extract::<f64>().unwrap(), 1.0);

            // Convert test case to Python bytes
            let py_test_case = PyList::new(py, &point.test_case);
            assert_eq!(py_test_case.len(), 3);
            assert_eq!(py_test_case.get_item(0).unwrap().extract::<u8>().unwrap(), 10);
        });
    }

    #[test]
    fn test_python_targeting_system_interface() {
        Python::with_gil(|py| {
            let system = TargetingSystem::new(5, 2.0);
            
            // Simulate Python target function call
            let py_result = py.eval("{'value': 42.0, 'label': 'test'}", None, None).unwrap();
            let value: f64 = py_result.get_item("value").unwrap().extract().unwrap();
            let label: String = py_result.get_item("label").unwrap().extract().unwrap();
            
            let observation = TargetObservation {
                value,
                label,
                metadata: HashMap::new(),
            };
            
            system.observe(observation.clone());
            let observations = system.get_observations();
            assert_eq!(observations.len(), 1);
            assert_eq!(observations[0].value, 42.0);
            assert_eq!(observations[0].label, "test");
        });
    }
}

// Integration tests with ChoiceSystem
#[cfg(test)]
mod choice_integration_tests {
    use super::*;
    use crate::choice::{ChoiceType};

    #[test]
    fn test_targeting_with_choice_generation() {
        let mut system = TargetingSystem::new(10, 1.0);
        system.add_target_function(Arc::new(MinimizeTarget::new("choices".to_string())));
        
        let mut data = ConjectureData::for_buffer(vec![0, 50, 100, 150, 200]);
        
        // Generate choices and track targeting
        let choice1 = data.draw_integer(0, 100).unwrap();
        let choice2 = data.draw_integer(0, 100).unwrap();
        
        let test_case = data.buffer.clone();
        let objectives = system.evaluate_and_update(&data, test_case.clone());
        
        assert!(!objectives.is_empty());
        
        // Observe coverage for choices
        system.coverage_generator().observe_coverage(
            format!("choice_{}_{}", choice1, choice2),
            test_case
        );
        
        let (branches, _) = system.coverage_generator().coverage_stats();
        assert_eq!(branches, 1);
    }

    #[test]
    fn test_guided_choice_selection() {
        let system = TargetingSystem::new(5, 1.0);
        
        // Simulate multiple test runs with coverage guidance
        for i in 0..5 {
            let seed = system.coverage_generator().get_interesting_seed()
                .unwrap_or_else(|| vec![i as u8; 4]);
            
            let mut data = ConjectureData::for_buffer(seed);
            
            if let Ok(choice) = data.draw_integer(0, 100) {
                system.coverage_generator().observe_coverage(
                    format!("integer_choice_{}", choice % 10),
                    data.buffer.clone()
                );
            }
        }
        
        let (branches, regions) = system.coverage_generator().coverage_stats();
        assert!(branches > 0);
    }

    #[test]
    fn test_multi_choice_targeting() {
        let mut system = TargetingSystem::new(8, 1.5);
        system.add_target_function(Arc::new(MaximizeTarget::new("diversity".to_string())));
        
        let test_cases = vec![
            vec![10, 20, 30, 40],      // Low entropy
            vec![0, 85, 170, 255],     // High entropy  
            vec![50, 51, 52, 53],      // Sequential
            vec![100, 25, 200, 75],    // Mixed
        ];
        
        for test_case in test_cases {
            let mut data = ConjectureData::for_buffer(test_case.clone());
            
            // Generate different choice types
            if data.buffer.len() >= 4 {
                let _ = data.draw_integer(0, 100);
                let _ = data.draw_boolean(0.5);
                let _ = data.draw_bytes(2);
            }
            
            system.evaluate_and_update(&data, test_case);
        }
        
        let points = system.get_pareto_points();
        assert!(!points.is_empty());
        
        // Verify diversity objectives are reasonable
        for point in &points {
            assert!(point.objectives[0] >= 0.0);
        }
    }
}

// Performance benchmarks
#[cfg(test)]
mod performance_tests {
    use super::*;
    use std::time::Instant;

    #[test]
    fn test_pareto_frontier_performance() {
        let mut frontier = ParetoFrontier::new(100);
        
        let start = Instant::now();
        
        // Add many points
        for i in 0..1000 {
            let point = ParetoPoint {
                objectives: vec![i as f64 % 50.0, (1000 - i) as f64 % 50.0],
                test_case: vec![i as u8],
                observations: vec![],
            };
            frontier.add_point(point);
        }
        
        let duration = start.elapsed();
        println!("Added 1000 points in {:?}", duration);
        
        // Should maintain reasonable size
        assert!(frontier.points().len() <= 100);
        assert!(duration.as_millis() < 1000); // Should be fast
    }

    #[test]
    fn test_coverage_generator_performance() {
        let generator = CoverageGuidedGenerator::new(10.0);
        
        let start = Instant::now();
        
        // Simulate heavy coverage tracking
        for i in 0..10000 {
            generator.observe_coverage(
                format!("branch_{}", i % 100),
                vec![(i % 256) as u8; 10]
            );
        }
        
        let duration = start.elapsed();
        println!("Tracked 10000 observations in {:?}", duration);
        
        let (branches, regions) = generator.coverage_stats();
        assert_eq!(branches, 100); // 100 unique branches
        assert!(regions > 0);
        assert!(duration.as_millis() < 5000); // Should be reasonably fast
    }

    #[test]
    fn test_targeting_system_scalability() {
        let mut system = TargetingSystem::new(50, 5.0);
        
        // Add multiple target functions
        for i in 0..10 {
            system.add_target_function(Arc::new(MinimizeTarget::new(format!("target_{}", i))));
        }
        
        let start = Instant::now();
        
        // Evaluate many test cases
        for i in 0..1000 {
            let test_case = vec![(i % 256) as u8; 20];
            let data = ConjectureData::for_buffer(test_case.clone());
            system.evaluate_and_update(&data, test_case);
        }
        
        let duration = start.elapsed();
        println!("Evaluated 1000 test cases with 10 objectives in {:?}", duration);
        
        let points = system.get_pareto_points();
        assert!(points.len() <= 50);
        assert!(duration.as_millis() < 10000); // Should scale reasonably
    }
}